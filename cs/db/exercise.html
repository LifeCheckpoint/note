<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <title class="nonu">数据库习题</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="../../css/note.css" />
</head>
<body>

<pre>
	[1] 1 5 6 9 14 17
	[2] 1 3 4 5
	[3] 1 6 7
	[4] 1 4 5 11
	[5] 1 2 3 4
	[6] -
	[7] 1 2 15
	[8] -
	[9] - (跳过)
	[10] 1 2 3 6 9
	[11] 1 2 3 5 6 7 8
	sql 语句 e-r 图
</pre>

<h2>绪论</h2>

<ol>
	<li>试述数据、数据库、数据库管理系统、数据库系统的概念。
		<ul class="answer">
			<li>描述事物的符号记录称为<b>数据</b>。描述事物的符号可以是数字，也可以是文字、图形、声音、正文、流数据、HTML、XML等等，数据的种类十分丰富。数据与其语义是不可分的。</li>
			<li><b>数据库</b>是长期储存在计算机内、有组织的、可共享的数据集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。</li>
			<li><b>数据库管理系统</b> (DBMS) 是位于用户与操作系统之间的一层数据管理软件，用于科学地组织和存储数据、高效地获取和维护数据。DBMS 主要功能包括数据定义功能、数据操纵功能、数据库的运行管理功能、数据库的建立和维护功能。</li>
			<li><b>数据库系统</b> (DBS) 是一个人-机系统，指在计算机系统中引入数据库后的系统构成。数据库系统由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员构成。</li>
		</ul>
	</li>
	<li></li>
	<li></li>
	<li></li>
	<li>试述数据库系统的特点。
		<ul class="answer">
			数据库系统的主要特点有：
			<li>数据结构化。数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的本质区别。</li>
			<li>数据库的共享性高，冗余度低，易扩充。数据库的数据不再面向某个应用而是面向整个系统，因此可以被多个用户、多个应用、用多种不同的语言共享使用，而且容易增加新的应用，这就使得数据库系统易于扩充，我们称之为弹性大。</li>
			<li>数据独立性高。数据独立性包括数据的物理独立性的数据和逻辑独立性。数据库管理系统的模式结构和二级映像功能保证了数据库中的数据具有很高的物理独立性和逻辑独立性。</li>
			<li>数据由 DBMS 统一管理和控制。数据库的共享是并发的共享，即多个用户可以同时存取数据库中的数据甚至可以同时存取数据库中同一个数据。为此，DBMS 必须提供统一的数据控制功能，包括数据的安全性保护，数据的完整性检查，并发控制和数据库恢复。</li>
		</ul>
	</li>
	<li>数据库管理系统的主要功能有哪些？
		<ul class="answer">
			<li>数据定义功能；</li>
			<li>数据组织、存储和管理功能</li>
			<li>数据操纵功能；</li>
			<li>数据库的事务管理和运行管理；</li>
			<li>数据库的建立和维护功能；</li>
			<li>其他功能，例如不同数据库之间的互访和互操作功能等等。</li>
		</ul>
	</li>
	<li></li>
	<li></li>
	<li>试述数据模型的概念、数据模型的作用和数据模型的三个要素。
		<ul class="answer">
			数据模型是数据库中用来对现实世界进行抽象的工具，是数据库中用于提供信息表示和操作手段的形式构架。一般地讲，数据模型是严格定义的概念的集合。这些概念精确地描述系统的静态特性、动态特性和完整性约束条件。因此数据模型通常由数据结构、数据操作和完整性约束三部分组成。
			<li><b>数据结构</b>是所研究的对象类型的集合，是对系统的静态特性的描述。</li>
			<li><b>数据操作</b>是指对数据库中各种对象（型）的实例（值）允许进行的操作的集合，包括操作及有关的操作规则，是对系统动态特性的描述。</li>
			<li><b>数据的约束条件</b>是完整性规则的集合，完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。</li>
		</ul>
	</li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li>试述关系数据库的特点。
		<ul class="answer">
			关系数据模型具有下列优点：
			<li>关系模型与非关系模型不同，它是建立在严格的数学概念的基础上的。</li>
			<li>关系模型的概念单一，无论实体还是实体之间的联系都用关系表示。操作的对象和操作的结果都是关系，所以其数据结构简单、清晰，用户易懂易用。</li>
			<li>关系模型的存取路径对用户透明，从而具有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作。</li>
			当然，关系数据模型也有缺点，其中最主要的缺点是，由于存取路径对用户透明，查询效率往往不如非关系数据模型。因此为了提高性能，必须对用户的查询请求进行优化，增加了开发数据库管理系统软件的难度。
		</ul>
	</li>
	<li></li>
	<li></li>
	<li>什么叫数据与程序的物理独立性？什么叫数据与程序的逻辑独立性？为什么数据库系统具有数据与程序的独立性？
		<ul class="answer">
			<li>数据与程序的逻辑独立性：当模式改变时（例如增加新的关系、新的属性、改变属性的数据类型等），由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。</li>
			<li>数据与程序的物理独立性：当数据库的存储结构改变了，由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性，简称数据的物理独立性。</li>
			数据库管理系统在三级模式之间提供的两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。
		</ul>
	</li>
	<li></li>
	<li></li>
</ol>

<h2>关系数据库</h2>

<ol class="enum">
	<li>试述关系模型的三个组成部分。
		<p class="answer">
			关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成。
		</p>
	</li>
	<li></li>
	<li>定义并理解下列术语，说明它们之间的联系与区别：
		<ol>
			<li>域，笛卡尔积，关系，元组，属性；</li>
			<li>主码，候选码，外码；</li>
			<li>关系模式，关系，关系数据库。</li>
		</ol>
		<ol class="answer">
			<li>域是一组具有相同数据类型的值的集合。</li>
			<li>笛卡尔积：给定一组域 `D_1, D_2, cdots,
				D_n`，这些域中可以有相同的。这组域的笛卡尔积为
				<span class="formula">
					`D_1 xx D_2 xx cdots xx D_n`
					`= {(d_1, d_2, cdots, d_n):`
					`d_i in D_i, i = 1, 2, cdots, n}`
				</span>
				其中每一个元素 `(d_1, d_2, cdots, d_n)` 叫作一个 `n` 元组
				(`n`-tuple) 或简称元组 (tuple)。元组中的每个值 `d_i`
				叫作一个分量 (component)。
			</li>
			<li>关系：在域 `D_1, D_2, cdots, D_n` 上笛卡尔积 `D_1 xx D_2
				xx cdots xx D_n` 的子集称为关系，表示为
				`R(D_1, D_2, cdots, D_n)`。
			</li>
			<li>元组：关系中的每个元素是关系中的元组。</li>
			<li>属性：关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域。由于域可以相同，为了加以区分，必须对每列起一个名字，称为属性
			(attribute)。</li>
			<li>候选码：若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码 (candidate key)。</li>
			<li>主码：若一个关系有多个候选码，则选定其中一个为主码
				(primary key)。</li>
			<li>外部码：设 `F` 是基本关系 `R` 的一个或一组属性，但不是关系
			`R` 的码，如果 `F` 与基本关系 `S` 的主码 `K_S` 相对应，则称
			`F` 是基本关系 `R` 的外部码 (foreign key)，简称外码。</li>
			<li>关系模式：关系的描述称为关系模式 (relation
				schema)。它可以形式化地表示为
				`R(U, D, "dom", F)`，其中 `R` 为关系名，`U`
				为组成该关系的属性名集合，`D` 为属性组 `U`
				中属性所来自的域，`"dom"` 为属性向域的映像集合，`F`
				为属性间数据的依赖关系集合。
			</li>
			<li>关系：在域 `D_1, D_2, cdots, D_n` 上笛卡尔积 `D_1 xx D_2
				xx cdots xx D_n` 的子集称为关系，表示为
				`R(D_1, D_2, cdots, D_n)`。(题目要求我再解释一遍的...)
				关系是关系模式在某一时刻的状态或内容。关系模式是静态的、
				稳定的，而关系是动态的、随时间不断变化的，
				因为关系操作在不断地更新着数据库中的数据。
			</li>
			<li>关系数据库：关系数据库也有型和值之分。关系数据库的型也称为关系数据库模式，是对关系数据库的描述，它包括若干域的定义以及在这些域上定义的若干关系模式。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。</li>
		</ol>
	</li>
	<li>举例说明关系模式和关系的区别。
		<p class="answer">
			关系是关系模式在某一时刻的状态或内容。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。例如，学生关系模式在不同的学年，学生关系是不同的。在实际工作中，人们常常把关系模式和关系都笼统地称为关系，这不难从上下文中加以区别，希望读者注意。
		</p>
	</li>
	<li>试述关系模型的完整性规则。在参照完整性中，什么情况下外码属性的值可以为空值？
		<ul class="answer">
			关系模型的完整性规则是对关系的某种约束条件。关系模型中可以有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。
			其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。
			<li>实体完整性规则要求：基本关系的主属性（即构成主码的任一属性）不能取空值。</li>
			<li>参照完整性规则要求：若属性（或属性组）`F`
			是基本关系 `R` 的外码，它与基本关系 `S` 的主码 `K_S`
			相对应（`R` 与 `S` 可以是同一个关系），则 `R` 中每个元组在
			`F` 上或者全部取空值，或者等于 `S` 中某个元组的主码值。</li>
			<li>用户定义的完整性是针对某一具体关系数据库的约束条件。它反映某一具体应用所涉及的数据必须满足的语义要求。</li>
			在参照完整性中，外部码属性的值可以为空，它表示该属性的值尚未确定，但前提条件是该外部码属性不是其所在关系的主属性。
		</ul>
	</li>
	<li></li>
	<li></li>
	<li></li>
</ol>

<h2>关系数据库标准语言 SQL</h2>

<ol>
	<li>试述 SQL 的特点。
		<ul class="answer">
			<li>综合统一。SQL 语言集数据定义语言 DDL、数据操纵语言 DML、数据控制语言 DCL 的功能于一体。</li>
			<li>高度非过程化。用 SQL 语言进行数据操作，只要提出“做什么”，而无须指明“怎么做”，因此无需了解存取路径。存取路径的选择以及 SQL 语句的操作过程由系统自动完成。</li>
			<li>面向集合的操作方式。SQL 语言采用集合操作方式，不仅操作对象、查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合。</li>
			<li>以同一种语法结构提供两种使用方式。SQL 语言既是自含式语言，又是嵌入式语言。它既能够作为自含式语言，独立地用于联机交互的使用方式，也能够嵌入到高级语言程序中，供程序员设计程序时使用。</li>
			<li>语言简捷，易学易用。</li>
		</ul>
	</li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li>什么是基本表？什么是视图？两者的区别和联系是什么？
		<ul class="answer">
			<li>基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。</li>
			<li>视图是从一个或几个基本表导出的表。</li>
			<li>视图本身不独立存储在数据库中，是一个虚表。即数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。视图在概念上与基本表等同，用户可以如同基本表那样使用视图，可以在视图上再定义视图。</li>
		</ul>
	</li>
	<li>试述视图的优点。
		<ul class="answer">
			<li>能够简化用户的操作。</li>
			<li>使用户能以多种角度看待同一数据。</li>
			<li>对重构数据库提供了一定程度的逻辑独立性。</li>
			<li>能够对机密数据提供安全保护。</li>
		</ul>
	</li>
	<li></li>
	<li></li>
</ol>

<h2>数据库安全性</h2>

<ol>
	<li>什么是数据库的安全性？
		<p class="answer">
			数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏。
		</p>
	</li>
	<li></li>
	<li></li>
	<li>试述实现数据库安全性控制的常用方法和技术。
		<ul class="answer">
			<li>用户标识和鉴别：由系统提供一定的方式让用户标识自己的名字或身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供系统的使用权。</li>
			<li>存取控制：通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库，所有未被授权的人员无法存取数据。</li>
			<li>视图机制：为不同的用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护。</li>
			<li>审计：建立审计日志，把用户对数据库的所有操作自动记录下来放入审计日志中，DBA
			可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。</li>
			<li>数据加密：对存储和传输的数据进行加密处理，从而使得不知道解密算法的人无法获知数据的内容。</li>
		</ul>
	</li>
	<li>什么是数据库中的自主存取控制方法和强制存取控制方法？
		<ul class="answer">
			<li>自主存取方法：定义各个用户对不同数据对象的存取权限。当用户对数据库访问时首先检查用户的存取权限。防止不合法用户对数据库的存取。</li>
			<li>强制存取控制方法：每一个数据对象被（强制地）标以一定的密级，每一个用户也被（强制地）授予某一个级别的许可证。系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象。</li>
			自主存取控制中自主的含义是：用户可以将自己拥有的存取权限“自主”地授予别人。即用户具有一定的“自主”权。
		</ul>
	</li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li>什么是数据库的审计功能，为什么要提供审计功能？
		<ul class="answer">
			<li>审计功能是指 DBMS 的审计模块在用户对数据库执行操作的同时把所有操作自动记录到系统的审计日志中。</li>
			<li>因为任何系统的安全保护措施都不是完美无缺的，蓄意盗窃破坏数据的人总可能存在。利用数据库的审计功能，DBA 可以根据审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。</li>
		</ul>
	</li>
</ol>

<h2>数据库完整性</h2>

<ol>
	<li>什么是数据库的完整性？
		<p class="answer">数据库的完整性是指数据的正确性和相容性。</p>
	</li>
	<li>数据库的完整性概念与数据库的安全性概念有什么区别和联系？
		<p class="answer">
			数据的完整性和安全性是两个不同的概念，但是有一定的联系。
			前者是为了防止数据库中存在不符合语义的数据，防止错误信息的输入和输出，即所谓垃圾进垃圾出
			(Garbage In Garbage Out) 所造成的无效操作和错误结果。
			后者是保护数据库防止恶意的破坏和非法的存取。
			也就是说，安全性措施的防范对象是非法用户的非法操作，完整性措施的防范对象是不合语义的数据。
		</p>
	</li>
	<li>什么是数据库的完整性约束条件？
		<p class="answer">
			完整性约束条件是指数据库中的数据应该满足的语义约束条件。
		</p>
	</li>
	<li>关系数据库管理系统的完整性控制机制应具有哪三方面的功能？
		<ul class="answer">
			DBMS 的完整性控制机制应具有三个方面的功能：
			<li>定义功能，即提供定义完整性约束条件的机制。</li>
			<li>检查功能，即检查用户发出的操作请求是否违背了完整性约束条件。</li>
			<li>违约反应，如果发现用户的操作请求使数据违背了完整性约束条件，则采取一定的动作来保证数据的完整性。</li>
		</ul>
	</li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
</ol>

<h2>关系数据理论</h2>

<ol>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
</ol>

<h2>数据库设计</h2>

<ol>
	<li>试述数据库设计过程。
		<ul class="answer">
			数据库设计过程的六个阶段：
			<li>需求分析</li>
			<li>概念结构设计</li>
			<li>逻辑结构设计</li>
			<li>数据库物理设计</li>
			<li>数据库实施</li>
			<li>数据库运行和维护</li>
			这是一个完整的实际数据库及其应用系统的设计过程。不仅包括设计数据库本身，还包括数据库的实施、数据库运行和维护。
			设计一个完善的数据库应用系统往往是上述六个阶段的不断反复。
		</ul>
	</li>
	<li>试述数据库设计过程中形成的数据库模式。
		<ul class="answer">
			数据库结构设计的不同阶段形成数据库的各级模式，即：
			<li>在概念设计阶段形成独立于机器特点，独立于各个 DBMS
				产品的概念模式。在本篇中就是 E-R 图；</li>
			<li>在逻辑设计阶段将 E-R
				图转换成具体的数据库产品支持的数据模型，如关系模型，形成数据库逻辑模式；然后在基本表的基础上再建立必要的视图
			(View)，形成数据的外模式；</li>
			<li>在物理设计阶段，根据 DBMS
				特点和处理的需要，进行物理存储安排，建立索引，形成数据库内模式。</li>
		</ul>
	</li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li>什么是数据库的再组织和重构造？为什么要进行数据库的再组织和重构造？
		<ul class="answer">
			<li>数据库的再组织是指：按原设计要求重新安排存储位置、回收垃圾、减少指针链等，以提高系统性能。</li>
			<li>数据库的重构造则是指部分修改数据库的模式和内模式，即修改原设计的逻辑和物理结构。数据库的再组织是不修改数据库的模式和内模式的。</li>
			<li>进行数据库的再组织和重构造的原因：数据库运行一段时间后，由于记录不断增、删、改，会使数据库的物理存储情况变坏，降低了数据的存取效率，数据库性能下降，这时 DBA 就要对数据库进行重组织。DBMS 一般都提供数据重组织用的实用程序。数据库应用环境常常发生变化，如增加新的应用或新的实体，取消了某些应用，有的实体与实体间的联系也发生了变化等，使原有的数据库设计不能满足新的需求，需要调整数据库的模式和内模式。这就要进行数据库重构造。</li>
		</ul>
	</li>
</ol>

<h2>数据库编程</h2>

<ol>
	<li></li>
	<li></li>
	<li></li>
</ol>

<h2>关系查询处理和查询优化</h2>

<ol>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
</ol>

<h2>数据库恢复技术</h2>

<ol>
	<li>试述事务的概念及事务的 4 个特性。恢复技术能保证事务的哪些特性？
		<ul class="answer">
			事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位。事务具有四个特性：原子性 (Atomicity)、一致性 (Consistency)、隔离性 (Isolation) 和持续性 (Durability)。这个四个特性也简称为 ACID 特性。
			<li>原子性：事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做。</li>
			<li>一致性：事务执行的结果必须是使数据从一个一致性状态变到另一个一致性状态。</li>
			<li>隔离性：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
			<li>持续性：持续性也称永久性 (Permanence)，指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。</li>
			为了保证事务的原子性、一致性与持续性，DBMS 必须对事务故障、系统故障和介质故障进行恢复；为了保证事务的隔离性和一致性，DBMS 需要对并发操作进行控制。
		</ul>
	</li>
	<li>为什么事务非常正常结束时会影响数据库数据的正确性？请举例说明之。
		<p class="answer">
			事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。例如某工厂的库存管理系统中，要把数量为 Q 的某种零件从仓库 1 移到仓库 2 存放，则可以定义一个事务 T，T 包括两个操作：Q1 = Q1 - Q，Q2 = Q2 + Q，如果 T 非正常终止时只做了第一个操作，则数据库就处于不一致性状态，库存量无缘无故少了 Q。
		</p>
	</li>
	<li>登记日志文件时为什么必须先写日志文件，后写数据库？
		<p class="answer">
			把对数据的修改写到数据库中和把表示这个修改的日志记录到日志文件中是两个不同的操作。有可能在这两个操作之间发生故障，即这两个写操作只完成了一个。
			如果先写了数据库修改，而在运行记录中没有登记这个修改，则以后就无法恢复这个修改了。如果先写日志，但没有修改数据库，在恢复时只不过是多执行一次 UNDO 操作，并不会影响数据库的正确性。所以一定要先写日志文件，即首先把日志记录写到日志文件中，然后写数据库的修改。
		</p>
	</li>
	<li></li>
	<li></li>
	<li>针对不同的故障，试给出恢复的策略和方法。（即如何进行事务故障的恢复，如何进行系统故障的恢复，以及如何进行介质故障的恢复。）
		<ul class="answer">
			<li>事务故障的恢复：事务故障的恢复是由 DBMS
				自动完成的，对用户是透明的。DBMS 执行恢复步骤是：
				<ul>
					<li>反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。</li>
					<li>对该事务的更新操作执行逆操作，即并报日志记录中“更新前的值”写入数据库。</li>
					<li>继续反向扫描日志文件，做同样处理。</li>
					<li>如此处理下去，直到读到此事务的开始标记，该事务故障的恢复就完成了。</li>
				</ul>
			</li>
			<li>系统故障的恢复：系统故障可能会造成数据库处于不一致状态：
				一是未完成事务对数据库的更新可能已写入数据库；二是已提交事务对数据库的更新可能还留在缓冲区，没来得及写入数据库。因此恢复操作就是要撤销
				(UNDO) 故障发生时未完成的事务，重做 (REDO)
				已提交但未写入数据库的的事务。
				<ul>系统的恢复步骤是：
					<li>正向扫描日志文件，找出在故障发生前已经提交的事务队列 (REDO 队列) 和未完成的事务队列 (UNDO 队列)。</li>
					<li>对撤销队列中的各个事务进行 UNDO 处理。进行 UNDO 处理的方法是，反向扫描日志文件，对每个 UNDO 事务的更新操作执行逆操作，即将日志记录中“更新前的值”(Before Image) 写入数据库。</li>
					<li>对重做队列中的各个事务进行 REDO 处理。进行 REDO 处理的方法是：正向扫描日志文件，对每个 REDO 事务重新执行日志文件登记的操作。即将日志记录中“更新后的值” (After Image) 写入数据库。</li>
				</ul>
			</li>
			<li>介质故障的恢复：介质故障是最严重的一种故障。恢复方法是重装数据库，然后重做已完成的事务，具体过程是：
			<ul>
				<li>DBA 装入最新的数据库后备副本（离故障发生时刻最近的转储副本），使数据库恢复到转储时的一致性状态。</li>
				<li>DBA 装入转储结束时刻的日志文件副本。</li>
				<li>DBA 启动系统恢复命令，由 DBMS 完成恢复功能，即重做已完成的事务。</li>
			</ul>
			</li>
		</ul>
	</li>
	<li></li>
	<li></li>
	<li>试述使用检查点方法进行恢复的步骤。
		<ul class="answer">
			<li>在重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录。</li>
			<li>由该检查点记录得到检查点建立时刻所有正在执行的事务清单
				ACTIVE-LIST。这时建立两个事务队列：
				<ul>
					<li>UNDO-LIST：需要执行 undo 操作的事务集合；</li>
					<li>REDO-LIST：需要执行 redo 操作的事务集合；</li>
				</ul>
				把 ACTIVE-LIST 暂时放入 UNDO-LIST 队列，REDO 队列暂为空。
			</li>
			<li>从检查点开始正向扫描日志文件
				<ul>
					<li>如有新开始的事务 `T_i`，把 `T_i` 暂时放入
						UNDO-LIST 队列；
					</li>
					<li>如有提交的事务 `T_j`，把 `T_j` 从 UNDO-LIST
						队列移到 REDO-LIST 队列，直到日志文件结束。</li>
				</ul>
			</li>
			<li>对 UNDO-LIST 中的每个事务执行 UNDO 操作，对 REDO-LIST
				中的每个事务执行 REDO 操作。
			</li>
		</ul>
	</li>
	<li></li>
</ol>

<h2>并发控制</h2>

<ol>
	<li>在数据库中为什么要并发控制？并发控制技术能保证事务的哪些特性？
		<p class="answer">
			数据库是共享资源，通常有许多个事务同时在运行。当多个事务并发地存取数据库时就会产生同时读取和/或修改同一数据的情况。若对并发操作不加控制就可能会存取和存储不正确的数据，破坏数据库的一致性。所以数据库管理系统必须提供并发控制机制。并发控制可以保证事务的一致性和隔离性。
		</p>
	</li>
	<li>并发操作可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况？
		<ul class="answer">
			并发操作带来的数据不一致性包括三类：丢失修改、不可重复读和读“脏”数据。
			<li>丢失修改 (Lost Update)。两个事务 `T_1` 和 `T_2`
				读入同一数据并修改，`T_2` 提交的结果破坏了（覆盖了）`T_1`
				提交的结果，导致 `T_1` 的修改丢失。</li>
			<li>不可重复读 (Non-Repeatable Read)。不可重复读是指事务 `T_1`
				读取某一数据后，事务 `T_2` 对其执行更新操作，使 `T_1`
				无法再现前一次读取结果。</li>
			<li>读“脏”数据 (Dirty Read)。读“脏”数据是指事务 `T_1`
				修改某一数据，并将其写回磁盘，事务 `T_2`
				读取同一数据后，`T_1` 由于某种原因被撤销，这时 `T_1`
				已修改过的数据恢复原值，`T_2`
				读到的数据与数据库中的数据不一致，则 `T_2`
				读到的数据就为“脏”数据，即不正确的数据。</li>
			避免不一致性的方法就是并发控制。最常用的并发控制技术是封锁技术。也可以用其他技术，例如在分布式数据库系统中，常常采用时间戳方法来进行并发控制。
		</ul>
	</li>
	<li>什么是封锁？基本的封锁类型有几种？试述它们的含义。
		<ul class="answer">
			封锁就是事务 T
			在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁，加锁后事务
			T 就对该数据对象有了一定的控制，在事务 T
			释放它的锁之前，其他的事务不能更新此数据对象。
			封锁是实现并发控制的一个非常重要的技术。
			基本的封锁类型有两种：排它锁 (Exclusive Locks，简称 X 锁)
			和共享锁 (Share Locks，简称 S 锁)。
			<li>排它锁又称为写锁。若事务 T 对数据对象 A 加上 X
				锁，则只允许 T 读取和修改 A，其他任何事务都不能再对 A
				加任何类型的锁，直到 T 释放 A 上的锁。这就保证了其他事务在
			T 释放 A 上的锁之前不能再读取和修改 A。</li>
			<li>共享锁又称为读锁。若事务 T 对数据对象 A 加上 S 锁，则事务
				T 就可以读 A 但不能修改 A，其他事务只能再对 A 加 S
				锁，而不能加 X 锁，直到 T 释放 A 上的 S
				锁。这就保证了其他事务可以读 A，但在 T 释放 A 上的 S
				锁之前不能对 A 做任何修改。</li>
		</ul>
	</li>
	<li></li>
	<li>什么是活锁？试述活锁的产生原因和解决方法。
		<div class="answer">
		如果事务 `T_1` 封锁了数据 R，事务 `T_2` 又请求封锁 R，于是 `T_2`
		等待。`T_3` 也请求封锁 R，当 `T_1` 释放了 R
		上的封锁之后系统首先批准了 `T_3` 的请求，`T_2` 仍然等待。然后
		`T_4` 又请求封锁 R，当 `T_3` 释放了 R 上的封锁之后系统又批准了
		`T_4` 的请求……`T_2`
		有可能永远等待，如下表所示。这就是活锁的情形。活锁的含义是该事务等待时间太长，似乎被锁住了，实际上可能被激活。
		<table>
			<tr>
				<td>`T_1`</td>
				<td>`T_2`</td>
				<td>`T_3`</td>
				<td>`T_4`</td>
			</tr>
			<tr>
				<td>lock R</td>
				<td>-</td>
				<td>-</td>
				<td>-</td>
			</tr>
			<tr>
				<td>-</td>
				<td>lock R</td>
				<td>-</td>
				<td>-</td>
			</tr>
			<tr>
				<td>-</td>
				<td>等待</td>
				<td>lock R</td>
				<td>-</td>
			</tr>
			<tr>
				<td>unlock</td>
				<td>等待</td>
				<td>-</td>
				<td>lock R</td>
			</tr>
			<tr>
				<td>-</td>
				<td>等待</td>
				<td>lock R</td>
				<td>等待</td>
			</tr>
			<tr>
				<td>-</td>
				<td>等待</td>
				<td>-</td>
				<td>等待</td>
			</tr>
			<tr>
				<td>-</td>
				<td>等待</td>
				<td>unlock</td>
				<td>等待</td>
			</tr>
			<tr>
				<td>-</td>
				<td>等待</td>
				<td>-</td>
				<td>lock R</td>
			</tr>
			<tr>
				<td>-</td>
				<td>等待</td>
				<td>-</td>
				<td>-</td>
			</tr>
		</table>
		活锁产生的原因：当一系列封锁不能按照其先后顺序执行时，就可能导致一些事务无限期等待某个封锁，从而导致活锁。
		避免活锁的简单方法是采用先来先服务的策略。当多个事务请求封锁同一数据对象时，封锁子系统按请求的先后次序对事务排队，数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁。
	</div>
	</li>
	<li>什么是死锁？请给出预防死锁的若干方法。
		<ul class="answer">
			如果事务 `T_1` 封锁了数据 `R_1`，`T_2` 封锁了数据 `R_2`，然后
			`T_1` 又请求封锁 `R_2`，因 `T_2` 已封锁了 `R_2`，于是 `T_1`
			等待 `T_2` 释放 `R_2` 上的锁。接着 `T_2` 又申请封锁
			`R_1`，`T_2` 也只能等待 `T_1` 释放 `R_1` 上的锁。这样就出现了
			`T_1` 在等待 `T_2`，而 `T_2` 又在等待 `T_1` 的局面，`T_1` 和
			`T_2` 两个事务永远不能结束，形成死锁。
			<table>
				<tr>
					<td>`T_1`</td>
					<td>`T_2`</td>
				</tr>
				<tr>
					<td>lock `R_1`</td>
					<td>-</td>
				</tr>
				<tr>
					<td>-</td>
					<td>lock `R_2`</td>
				</tr>
				<tr>
					<td>-</td>
					<td>-</td>
				</tr>
				<tr>
					<td>lock `R_2`</td>
					<td>-</td>
				</tr>
				<tr>
					<td>等待</td>
					<td>-</td>
				</tr>
				<tr>
					<td>等待</td>
					<td>lock `R_1`</td>
				</tr>
				<tr>
					<td>等待</td>
					<td>等待</td>
				</tr>
			</table>
			防止死锁的发生其实就是要破坏产生死锁的条件。预防死锁通常有两种方法：
			<li>一次封锁法。要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。</li>
			<li>顺序封锁法。预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。不过，预防死锁的策略不大适合数据库系统的特点。</li>
		</ul>
	</li>
	<li>请给出检测死锁发生的一种方法，当发生死锁后如何解除死锁？
		<ul class="answer">
			数据库系统一般采用的方法是：允许死锁发生，DBMS
			检测到死锁后加以解除。DBMS
			中诊断死锁的方法与操作系统类似，一般使用超时法或事务等待图法。
			<li>超时法是：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。超时法实现简单，但有可能误判死锁。事务因其他原因长时间等待超过时限时，系统会误认为发生了死锁。若时限设置得太长，又不能及时发现死锁发生。</li>
			DBMS并发控制子系统检测到死锁后，就要设法解除。通常采用的方法是选择一个处理死锁代价最小的事务，将其撤消，释放此事务持有的所有锁，使其他事务得以继续运行下去。当然，对撤销事务所执行的数据修改操作必须加以恢复。
		</ul>
	</li>
	<li>什么样的并发调度是正确的调度？
		<p class="answer">
			可串行化 (Serializable) 的调度是正确的调度。
			可串行化的调度的定义：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同，我们称这种调度策略为可串行化的调度。
		</p>
	</li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
</ol>

<script src="../../js/note.js?type=cs&loadmath=true"></script>
</body>
</html>
