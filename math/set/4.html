<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <title>自然数与序数</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="../../css/note.css" />
</head>
<body>

<h2>Peano 公理 <i>——自然数最早的公理化定义</i></h2>

<ol class="axiom">
	(Peano, 1889) 设 `NN` 是一个非空集合, `0 in NN` 是其中某一特定的元.
  `+` 是 `NN` 上一变换 (即 `NN` 到自身的映射), `(NN, 0, +)` 满足:
  <li>`0 !in "ran"(+)`, 即不存在 `x in NN`, 使得 `0 = x^+`;</li>
  <li>`+` 是一单射, 即 `x^+ = y^+ rArr x = y`;</li>
  <li>归纳原理: `AA E sube NN`, 如果 (1) `0 in E`; (2) `n in E rArr n^+ in
    E`, 那么 `E = NN`.
	</li>
</ol>

<p class="corollary">
  <b>零的惟一性</b>
  设 `n in NN`,  则
  <span class="formula">
    `n != 0` `iff EE x in NN`, `n = x^+`.
  </span>
  即, `NN` 中仅有 0 满足 Peano 公理的性质 1.
</p>

<p class="proof">
  `lArr` 由公理可知, 下证 `rArr`.
  反设 `n in NN`, `n != 0`, 且 `AA x in NN`, `n != x^+`.
  用 `E` 表示与 `n` 不相等的所有自然数, 因此 `0 in E`.
  若 `x in E`, 即 `x != n`, 由假设 `n != x^+` 成立, 故 `x^+ in E`.
  由归纳原理知 `E = NN`, 即 `n` 不与任何自然数相等, 矛盾; 因此 `n = 0`.
</p>

<p class="theorem">
  <b>自然数的惟一性</b>
  满足 Peano 公理的系统都彼此同构; 因此在同构意义下, 自然数系统是惟一的.
  所谓 `(NN, 0, +)` 与 `(NN', 0', +')` 同构, 是指存在一个双射 `f: NN to
  NN'`, 使得
	<span class="formula">
		`f(0) = 0'`,
    `quad f(n^+) = f(n)^(+')`,
    `quad AA n in NN`.
	</span>
</p>

<ol class="proof">
  <li>由于 `0'` 是惟一的, 可以令 `f(0) = 0'`. 我们把 `f` 的定义域记为 `E`,
    因此 `0 in E`.
    对任意 `n in E`, 定义 `f(n^+) = f(n)^(+')`, 因此 `n^+` 也有定义, `n^+
    in E`.  由归纳原理, `E = NN`, `f` 在 `NN` 上有定义.
  </li>
  <li>下证 `f` 是满射, 即证 `AA n' in NN'`, `EE n in NN` 使 `n' = f(n)`.
    若 `n' = 0'`, 结论成立; 现在设结论在 `E sube NN'` 上成立,
    由已知 `0' in E`. 若 `n' = f(n)` 成立, 则 `{:n':}^(+') = f(n)^(+') =
    f(n^+)`, 结论也成立. 在 `NN'` 上应用归纳原理知结论成立.
  </li>
  <li>下证 `f` 是单射, 即证 `AA m, n in NN`, `f(m) = f(n) rArr m = n`.
    若 `m, n` 之中有一个为 `0`, 不妨设 `m = 0`, 则 `f(n) = f(0) = 0'`,
    若 `n != 0`, 则存在 `x in NN` 使 `x^+ = n`. 于是 `f(n) = f(x^+) =
    f(x)^(+') != 0`, 矛盾; 因此 `n = 0`.
    现在设 `f(m) = f(n) rArr m = n`, 则
    <span class="formula">
      `f(m^+) = f(n^+)`
      `iff f(m)^(+') = f(n)^(+')`
      `rArr f(m) = f(n)`
      `rArr m = n`.
    </span>
    在 `NN` 上应用归纳原理知结论成立.
  </li>
</ol>

<p>自然数集 `NN` 的惟一性已经得到保证.
  下面我们将在 ZFC 集合论中保证它的存在性.
</p>

<h2>在 ZFC 集合论体系内定义自然数</h2>

<h3>归纳集与归纳原理</h3>

<p class="definition">
	对任意集合 `x`, 定义 `x^+ := x uu {x}`, 称为 `x` 的<b>后继元
	(successor)</b>. 由配对公理, 并公理和外延公理, 后继元是存在惟一的.
  后继元就是把集合 `x` "放入自身" 所得到的集合, 如
  <span class="formula">
    `{a, b}^+ = {a, b, {a, b}}`.
  </span>
  显然有 `x in x^+`, `x sube x^+`.
</p>

<ol class="definition">
	称 `A` 是一个<b>归纳集 (inductive set)</b>, 如果
	<li>`O/ in A`;</li>
	<li>`x in A rArr x^+ in A`.</li>
</ol>

<p>	在集合论体系内引入下面的公理:</p>

<p class="axiom" id="axiom-inf">
  <b>无限公理</b> 归纳集是存在的.
</p>

<p class="corollary">
  设非空集合 `S` 的元素均为归纳集, 则 `uuu S` 是归纳集.
</p>

<p class="proof">
  `O/ in uuu S`; 若 `x in uuu S`, 则存在 `A in S` 使得 `x in A`.  于是 `x^+ in A sube uuu S`.
  因此 `uuu S` 是归纳集.
</p>

<p class="remark">
  归纳集的全体不构成集, 而是一个真类.
</p>

<p class="proof">
  [来自群友 幂零群]
  考虑全体归纳集 `S`. 若 `S` 是集合, 则定义 `S_0 := S`, `S_(n+1) := S_n^+`.
  应用替换公理模式, 将下文的自然数集 `omega` 替换为 `T := {S_n: n in omega}`,
  则 `omega uu T` 也是归纳集.
  有 `S in omega uu T in S`, 与正则公理矛盾.
</p>

<p class="definition">
  <b>自然数的定义</b>
  由无限公理, 归纳集存在. 将最小的归纳集记为 `omega`, 称为<b>自然数集</b>,
  它的元素称为<b>自然数</b>. 由归纳集定义,`O/ in omega`, 我们记 `0 := O/`,
  `1 := 0^+`, `2 := 1^+`, 等等:
  <span class="formula">
    `0 = O/`,<br>
    `1 = {0} = {O/}`,<br>
    `2 = {0, 1} = {O/, {O/}}`,<br>
    `3 = {0, 1, 2} = {O/, {O/}, {O/, {O/}}}`,<br>
    `cdots`
  </span>
  <br>
  但什么是 "最小" 的归纳集呢?  我们不能取 `omega` 为所有归纳集的交,
  因为归纳集的全体不构成集.  相对地, 取归纳集 `A`, 然后定义 `omega` 为 `A`
  的子集:
	<span class="formula">
		`omega := {x in A:` 对任意归纳集 `E` 有 `x in E}`
	</span>
  该集合的存在惟一性由子集公理和外延公理保证.
  下面证明, `omega` 确是一个归纳集, 并且是最小的归纳集.
</p>

<p class="proof">
	首先 `O/ in A`, 且对任意归纳集 `E` 有 `O/ in E`, 从而由 `omega`
	的定义, `O/ in omega`.<br/>
	其次, 若 `x in omega`, 则 `x in A`, 且对任意归纳集 `E` 有 `x in E`.
	于是分别由 `A, E` 是归纳集知, `x^+ in A`, 且对任意归纳集 `E` 有
	`x^+ in E`. 再由 `omega` 的定义知 `x^+ in omega`.<br/>
	由归纳集的定义, `omega` 是归纳集. 由 `omega` 的定义知对任意归纳集 `E`,
	`omega sube E`, 因此是最小的归纳集.
</p>

<p class="remark">
  这里使用记号 `omega` 而不是 `NN` 的理由是, 自然数有多种定义方式, `omega` 用来特指它的这一种定义.
</p>

<p class="remark">
  由自然数集的作法知道, "交" 的概念可以从集合的交推广到更一般情形: 真类的交.
  设 `cc C` 是一个真类 (其元素为集合, 而且非空, 毕竟空集不是真类), 先取 `A in cc C`, 然后令
  <span class="formula">
    `I := { x in A: AA E in cc C, x in E}`.
  </span>
  称 `I` 为真类 `cc C` 的交, 记为 `uuu cc C`.
</p>

<p>可以验证, 我们定义的自然数集 `omega` 适合 Peano 公理.
先证最有用的归纳原理:
</p>

<p class="corollary">
	<b>自然数归纳原理 (数学归纳法原理)</b>
	设 `T sube omega`, `0 in T` 且
	<span class="formula">
		`n in T rArr n^+ in T`,
	</span>
	则 `T = omega`. 于是 `omega` 满足 Peano 公理的 3.
</p>

<p class="proof">
	显然 `T` 是归纳集, 因此 `omega` 作为最小的归纳集, 有 `omega sube T`.
	但 `T sube omega`, 于是 `T = omega`.
</p>

<p class="remark">
	自然数归纳原理告诉我们, 要得到所有的自然数, 只需从 `0` 开始,
	每次按最近得到的数 `n`, 将 `n^+` 也加入到集合中来,
	这一过程无限地 (合法性由无限公理保证) 进行下去, 就得到全体自然数.
</p>

<p class="corollary">
	<b>`bm omega` 上的强归纳原理</b>
	设 `T sube omega`, 且
	<span class="formula">
		`n sube T rArr n in T`,
	</span>
	则 `T = omega`.
</p>

<p class="proof">
	令 `S = {n in omega: n sube T}`, 由定义 `S sube T sube omega`.<br/>
	首先 `0 in omega`, 且 `0 = O/ sube T`, 因此 `0 in S`.
	其次若 `n in S`, 则 `n sube T`, 于是 `n in T`,
	从而 `n^+ = n uu {n} sube T`. 又由定义 `omega` 是归纳集,
	所以由 `n in omega` 得到 `n^+ in omega`. 这推出 `n^+ in S`.
	于是由自然数归纳原理, `S = omega`, 从而只能 `T = omega`.
</p>

<h3>传递集与单调性</h3>

<p>	本小节证明 `n mapsto n^+` 是单射. 为此引入传递集的概念.</p>

<p class="definition">
	称 `A` 为一<b>传递集 (transitive set)</b>, 如果 "`in`" 的传递性在 `A` 上成立:
	<span class="formula">
		`EE x (t in x ^^ x in A) rArr t in A`.
	</span>
	由于 `x in O/` 是伪命题, 上式的前件为假, 因此对 `A = O/` 上式为真,
	即 `O/` 是传递集.
</p>

<p class="example">
  自然数 0, 1, 2... 均为传递集: `O/`, `{O/}`, `{O/, {O/}}`...
</p>

<p class="remark">
  传递集的全体也是一个真类. 我们将在序数一节中说明.
</p>

<ol class="theorem">
	`AA A`, 下列命题等价:
	<li>`A` 是传递集;</li>
	<li>`uuu A sube A`;</li>
	<li>`a in A rArr a sube A`; 即 `A` 的每个元素都是自身的子集.</li>
	<li>`A sube 2^A`.</li>
</ol>

<ol class="proof">
	<li>`rArr` 2. 设 `t in uuu A`, 则 `EE x in A`, `t in x`.
		由传递集的定义得 `t in A`.
	</li>
	<li>`rArr` 3. 设 `a in A`, 则 `a sube uuu A`. 由 2, `uuu A sube A`,
		所以 `a sube A`.
	</li>
	<li>`iff` 4. 显然.</li>
	<li>`rArr` 1. 设 `t in x`, `x in A`. 由 4, `x in 2^A`, 即 `x sube A`.
		再由 `t in x` 得 `t in A`.
	</li>
</ol>

<p class="theorem">
  <b>后继的逆运算</b>
  若 `x` 是传递集, 则 `uuu x^+ = x`.
</p>

<p class="proof">
	`x^+ = x uu {x}`, 显然 `x in x^+`, 故 `x sube uuu x^+`.
	<br/>
	设 `a in x^+ = x uu {x}`, 则 `a in x` 或 `a = x`. 由 `x` 是传递集知
	`a sube x` 或 `a = x`. 从而 `x^+` 的每一元素都是 `x` 的子集,
	有 `uuu x^+ sube x`.
</p>

<ol class="corollary">
  传递集的性质
  <li>传递集的后继也是传递集.</li>
  <li>若非空集合 `S` 的元素皆是传递集, 则 `nnn S`, `uuu S` 是传递集.</li>
</ol>

<ol class="proof">
  <li>设 `x` 是传递集, 则 `uuu x^+ = x sube x^+`, 所以 `x^+` 也是传递集.</li>
  <li>取 `x in nnn S`, 则 `AA y in S`, `x in y`.
    由 `y` 是传递集知 `x sube y`. 再由 `y` 的任意性知 `x sube nnn S`. 故 `nnn S` 是传递集.
    <br>
    `uuu S` 的证明类似.
  </li>
</ol>

<p class="corollary">
  由于 `0 = O/` 是传递集, 而每个传递集的后继仍是传递集, 根据归纳原理知, 每个自然数都是传递集.
</p>

<p>	平行于强归纳原理, 有:</p>

<p class="corollary">
	`omega` 本身也为一传递集.
</p>

<p class="proof">
	令 `T = {x in omega: x sube omega}`,<br/>
	首先 `0 in omega`, 且 `0 = O/ sube omega`, 所以 `0 in T`.
	其次若 `n in T`, 即 `n in omega`, `n sube omega`, 于是
	`n^+ = n uu {n} sube omega`. 又由 `omega` 是归纳集和 `n in omega` 推出
	`n^+ in omega`. 这推出 `n^+ in T`. 于是由自然数归纳原理 `T = omega`.
	但 `T` 是一传递集: `AA t in T`, `t sube omega = T`.
	所以 `omega` 也是传递集.
</p>

<p>	现在证明 Peano 公理的 2, 即变换 `n mapsto n^+` 是单射.</p>

<ol class="theorem">
	<li>`(AA m, n in omega)` `m = n iff m^+ = n^+`;</li>
	<li>`(AA n in omega)` `n != n^+`.</li>
</ol>

<ol class="proof">
	<li>只需证 `m^+ = n^+ rArr m = n`. 设 `m^+ = n^+`, 则
		`uuu m^+ = uuu n^+`, 但 `m, n` 为传递集, 所以 `uuu m^+ = m`,
		`uuu n^+ = n`, 从而 `m = n`.
	</li>
	<li>令 `T = {n in omega: n != n^+}`.
        首先因为
		<span class="formula">
          `0^+ = {O/} != O/ = 0`,
		</span>
		所以 `0 in T`.<br/>
		其次若 `n in T`, 则 `n != n^+`, 由 1 有 `n^+ != n^(+ +)`,
		从而 `n^+ in T`, 由归纳原理, `T = omega`.
	</li>
</ol>

<p>	最后, `AA n in omega`, `n^+ = n uu {n} != O/ = 0`.
	即 `omega` 满足 Peano 公理的 1, 从而 `omega` 是一个 Peano 系统.
</p>

<h2>序数</h2>

<p>[来自 李文威《代数学方法》]</p>

<h3>序数类</h3>

<ol class="definition">
  <b>(von Neumann)</b>
  称集合 `alpha` 是一个<b>序数</b>, 如果
  <li>`alpha` 是传递集. 即 `alpha` 的每个元素都是 `alpha` 的子集, 换言之 `alpha sube cc P(alpha)`.</li>
  <li>`alpha` 的元素按从属关系 "`in`" 构成良序, 即 `(alpha, in)` 是良序集.</li>
  每个自然数都是序数; `omega` 也是序数.
</ol>

<p class="remark">
  由正则公理知道, 不存在从属关系的无穷降链, 因此 `alpha` 的每个非空子集总是有极小元,
  从而条件 2 可以减弱为全序.
</p>

<p class="corollary">
  <b>序数中的极小元</b> [来自群友 幂零群]
  若 `alpha != O/` 是序数, 则 `alpha` 存在唯一极小元, 这个极小元就是 `O/`.
</p>

<p class="proof">
  由 `(alpha, in)` 是良序集知道 `alpha` 存在一个极小元 `m`.  假设 `m != O/`,
  取 `x in m`, 则由 `alpha` 的传递性和 `m in alpha` 知道 `x in alpha`.
  这与 `m` 的极小性矛盾, 因此 `m = O/`.
  再由空集的唯一性知 `alpha` 的极小元唯一.
</p>

<ol class="corollary">
  序数的性质
  <li>若 `alpha` 是序数, 则其后继 `alpha^+` 也是序数.</li>
  <li>若 `alpha` 是序数, 则它的元素 (如果存在) 也是序数.</li>
  <li>若 `alpha, beta` 是序数, 则 `alpha nn beta` 也是序数.</li>
</ol>

<ol class="proof">
  <li>这是因为传递集的后继也是传递集. 下证 `alpha^+ = alpha uu {alpha}` 是良序集.
    事实上和集合 `alpha` 相比, 集合 `alpha^+` 只多了一个元素 `alpha`,
    因此 `alpha^+` 中的其它元素皆是 `alpha` 的元素, 这指出 `alpha^+` 是全序, 且 `alpha` 是其中的最大元.
    添加一个最大元并不影响每个非空子集有极小元, 因此 `alpha^+` 是良序集.
  </li>
  <li>设 `beta in alpha`. 由 `alpha` 是传递集知 `beta sube alpha`. 因此 `beta`
    作为 `alpha` 的子集也是良序集.
    <br>
    又设 `x in tau in beta`,
    由 `alpha` 是传递集和 `tau in beta in alpha` 知道 `tau in alpha`.
    同理由 `x in tau in alpha` 知道 `x in alpha`.
    现在 `x, tau, beta` 皆是 `alpha` 的元素,
    由 `alpha` 上序关系的传递性知道 `x in beta`, 因此 `beta` 是传递集.
  </li>
  <li>
    首先由传递集的性质知道 `alpha nn beta` 是传递集,
    又良序集的子集也是良序集, 所以 `alpha nn beta` 是序数.
  </li>
</ol>

<ol class="corollary">
  序数之间的关系
  <li>若 `alpha, beta` 是序数, `alpha subne beta`, 则 `alpha in beta`.</li>
  <li>若 `alpha, beta` 是序数, 必有 `alpha sube beta` 或 `beta sube alpha`.</li>
  总之, 对任意两个序数 `alpha, beta`, 必有 `alpha in beta`, `beta in alpha`,
  `alpha = beta` 之一成立.
</ol>

<ol class="proof">
  <li>
    因为 `alpha` 真包含于 `beta`, 可令 `gamma` 为 `beta - alpha` 的极小元. 用 `lt` 表示 `in`,
    令 `X = {x in beta: x lt gamma}`, 下证 `X = alpha`.
    <br>
    事实上任取 `x in X`, 由 `x lt gamma` 知道 `x !in beta - alpha`, 即 `x in
    alpha`, 这证明了 `X sube alpha`.
    <br>
    另一方面任取 `y in alpha`, 由 `alpha` 的传递性有 `y sube alpha`, 因此
    `gamma !in y`, 即 `gamma` 不小于 `y`. `gamma` 也不等于 `y`, 这是因为 `gamma
    in beta - alpha` 而 `y in alpha`. 综上由于 `alpha` 是全序集, 只能 `y lt gamma`, 即 `y in X`.
    这证明了 `alpha sube X`.
    <br>
    把 `X` 定义中的 `lt` 换成 `in` 可知 `X = gamma`, 因此事实上我们证明了
    `alpha` 是 `beta - alpha` 的极小元.
  </li>
  <li>
    令 `gamma := alpha nn beta`, 则 `gamma` 也是序数, 我们证明必有 `gamma = alpha` 或 `gamma = beta`.
    否则, `gamma` 是 `alpha` 和 `beta` 的真子集. 由 1. 知道 `gamma in alpha`,
    `gamma in beta`, 从而 `gamma in gamma`, 与偏序的反称性矛盾 (或者说, 与正则公理矛盾).
  </li>
</ol>

<p class="definition">
  <b>序数类</b>
  我们把全体序数记为 `bb(On)`. 定义序数 `alpha lt beta` 当且仅当 `alpha in beta`,
  则 `(bb(On), lt)` 构成全序, 进而由正则公理知道它构成良序, 但不是良序集, 因为 `bb(On)` 不是一个集合!
</p>

<p class="lemma">
  若非空集合 `S` 的元素皆为序数, 则 `nnn S`, `uuu S` 是序数. 分别记作 `"inf"S` 和 `"sup"S`.
  特别有 `"inf"S in S`.
</p>

<div class="proof p">
  我们已经知道 `"inf" S`, `"sup" S` 是传递集.
  又 `(bb(On), lt)` 构成良序, 所以 `"inf" S`, `"sup" S` 都是良序集.
  <br>
  下证 `"inf"S in S`.
  因为 `"inf"S = nnn S`, 所以对任意序数 `alpha in S` 都有 `"inf"S sube alpha`.
  但 `"inf"S`, `alpha` 皆为序数, 所以必有 `"inf"S = alpha` 或 `"inf"S in alpha`.
  我们断言必存在 `alpha in S` 使得 `"inf"S = alpha`, 假如不然, 则对任意 `alpha in S` 都有 `"inf"S in alpha`, 于是 `"inf" S in nnn S = "inf"S`, 矛盾.
  <hr>
  注: 因为 `"inf"S in S`, 所以它实际是 `S` 中的最小序数. 我们还可以说明 `"sup"S` 是 `S` 的上确界.
  这是因为对任意 `alpha in S`, `alpha sube uuu S`, 从而 `alpha le S`, 说明它是上界.
  又任取 `beta lt "sup"S`, 则 `beta in uuu S`, 即存在 `S_0 in S` 使 `beta in
  S_0`, 即 `beta lt S_0`, 说明它是最小上界, 即上确界.
</div>

<ol class="remark">
  <li>我们已经学习过真类的交, 因此 `"inf" S` 定义中的 `S` 可以推广到真类.
    引理告诉我们, 任意一族序数都可以取其中的最小元.
  </li>
  <li>约定 `"sup" O/ = O/`.</li>
  <li>`"sup"S in S` 不一定成立, 比如 `"sup" omega = omega`.</li>
</ol>

<p class="theorem">
  <b>Burali-Forti 悖论 (1897)</b>
  全体序数 `bb(On)` 是一个真类.
  由于序数是特殊的传递集, 传递集的全体也是真类.
</p>

<p class="proof">
  假如 `bb(On)` 是一个集合, 则 `S := uuu bb(On)` 有定义, 且 `S` 也是一个序数.
  考虑 `S` 的后继 `S^+`, 它也是一个序数, 且严格大于全体序数.
  这是因为任取 `alpha in bb(On)`, 有 `alpha sube S`. 若 `alpha = S`, 则 `alpha = S in S^+`;
  若 `alpha != S`, 则 `alpha in S sube S^+`.
  但 `S^+` 自身也是一个序数, 这意味着 `S^+` 大于自身, 一个矛盾.
</p>

<p class="corollary">
  `bb(On)` 不能被嵌入到集合中.
  换言之, 对任意集合 `P`, 不存在单射 `bb(On) to P`.
</p>

<p class="proof">
  若存在这样的单射 `f`, 分离公理模式确保 `f(bb(On)) sube P` 是集合,
  而替换公理模式指出 `bb(On) = f^-1(f(bb(On)))` 亦是集合, 矛盾.
</p>


<h3>极限序数</h3>

<p class="definition">
  <b>极限序数</b>
  若序数 `alpha` 不是任何序数的后继, 则称 `alpha` 是极限序数.
  `O/`, `omega` 都是极限序数. 我们把小于 `omega` 的序数称为<b>有限序数</b>,
  而其它序数称为<b>无穷序数</b>.
  `omega` 是最小的无穷序数, 也是除了 `O/` 之外最小的极限序数.
</p>

<p class="remark">
  利用公式 `x = uuu x^+` 快速判断:
  如果 `alpha = uuu alpha`, 则它是极限序数; 否则不是.
</p>

<p class="lemma">
  <b>理解序数构造的钥匙</b> 设 `alpha` 是序数, 则
  <span class="formula">
    `alpha`
    `= {beta: beta in alpha}`
    `= {beta: beta lt alpha}`.
  </span>
  由此可知每个序数都是一个集合, 它恰好包含了小于它的所有序数.
  例如, `1 = {0}`, `2 = {0, 1}`, `omega = {0, 1, 2, ...}`
</p>

<ol class="corollary">
  <li>`alpha^+ = "inf"{beta: beta gt alpha}`, 因此 `alpha^+` 是大于 `alpha` 的最小序数.</li>
  <li>`beta lt alpha^+ iff beta le alpha`. 换言之不存在 `beta` 使得 `alpha lt beta lt alpha^+`.</li>
  <li>若 `alpha` 是极限序数, `beta lt alpha`, 则 `beta^+ lt alpha`.</li>
  <li>若 `alpha` 是极限序数, 则 `alpha = op(s u p) alpha` `= "sup"{beta: beta lt alpha}`.
    总之,
    <span class="formula">
      `op(s u p) alpha = { beta, if alpha = beta^+; alpha, otherwise :}`.
    </span>
  </li>
</ol>

<ol class="proof">
  <li>
    一方面, 显然 `alpha^+ gt alpha`, 所以 `alpha^+ supe nnn { beta: beta gt alpha }`,
    因为 `alpha^+` 是右边的交集的一员.
    <br>
    另一方面, 任取 `beta gt alpha`, 则有
    `alpha in beta`, `alpha sube beta`, 因此
    `alpha^+ = alpha uu {alpha} sube beta`.
    所以 `alpha^+ sube nnn {beta: beta gt alpha}`.
  </li>
  <li>
    这是上一条的推论.
  </li>
  <li>因为 `alpha` 是极限序数, 不可能有 `beta^+ = alpha`;
    另一方面, 因为 `beta^+` 是大于 `beta` 的最小序数, 也不可能有 `beta^+ gt alpha`.
    所以 `beta^+ lt alpha`.
  </li>
  <li>
    一方面, 对任意 `beta lt alpha`, 有 `beta sube alpha`, 因此 `alpha supe uuu {beta: beta lt alpha}`.
    另一方面, 由于 `alpha` 是极限序数, 对任意 `xi in alpha`, 取 `beta = xi^+`,
    由 3. 知 `xi in beta lt alpha`, 这证明了 `alpha sube uuu {beta: beta lt alpha}`.
  </li>
</ol>

<ol class="example">
  <b>构造非零极限序数的一种方法</b>
  设 `x` 是归纳集, 令
  <span class="formula">
    `alpha := { y in x: y sube x, y in bb(On) }`.
  </span>
  按定义验证以下性质:
  <li>`alpha` 非空.</li>
  <li>`alpha` 是序数.</li>
  <li>`y in alpha rArr y^+ in alpha`.</li>
  因此 `alpha` 是非零极限序数.
</ol>

<ol class="proof">
  <li>`O/ in alpha`.</li>
  <li>先证 `alpha` 是传递集.
    设 `y in alpha`, 则 `y` 是序数; 又设 `z in y`, 则 `z` 作为 `y` 的元素也是序数.
    于是 `z in y sube x`, `z sube y sube x`, 因此 `z in alpha`.
    又 `alpha` 的元素均为序数, 显然为一良序, 所以 `alpha` 是序数.
  </li>
  <li>设 `y in alpha`, 则 `y in x`. 但 `x` 是传递集, 所以 `y^+ in x`.
    又 `y in x`, `y sube x`, 所以 `y^+ = y uu {y} sube x`.
    因此 `y^+ in alpha`.
  </li>
</ol>

<h3>超穷递归 (超限归纳法)</h3>

<ol class="theorem">
  <b>超限归纳法</b>
  令 `C` 为一个由序数构成的类. 如果
  <li>`O/ in C`;</li>
  <li>`alpha in C rArr alpha^+ in C`;</li>
  <li>对于每个极限序数 `alpha`, 满足 `((AA beta lt alpha) beta in C) rArr alpha in C`.
  </li>
  那么 `C = bb(On)`. 如果仅考虑小于某 `theta` 的序数而非 `bb(On)` 整体, 断言依然成立.
</ol>

<p class="proof">
  反设 `C != bb(On)`. 取不在 `C` 中的最小序数 `alpha != O/`, 则无论它是后继或极限序数都导致矛盾.
</p>

<h3>序数的运算</h3>

<div class="definition p">
  设 `alpha, beta` 是序数, `gamma` 是极限序数,
  借助超穷递归原理定义序数的运算如下:
  <table>
    <tr>
      <th>加法</th>
      <td>`alpha + 0 := alpha`</td>
      <td>`alpha + beta^+ := (alpha + beta)^+`</td>
      <td>`alpha + gamma := "sup"{alpha + xi: xi lt gamma}`</td>
    </tr>
    <tr>
      <th>乘法</th>
      <td>`alpha * 0 := 0`</td>
      <td>`alpha * beta^+ := alpha * beta + alpha`</td>
      <td>`alpha * gamma := "sup"{alpha * xi: xi lt gamma}`</td>
    </tr>
    <tr>
      <th>指数</th>
      <td>`alpha^0 := 1`</td>
      <td>`alpha^(beta^+) := alpha^beta * alpha`</td>
      <td>`alpha^gamma := "sup"{alpha^xi: xi lt gamma}`</td>
    </tr>
  </table>
  在 `alpha, beta` 有限的情况下, 它们的运算与自然数相同.
</div>

<ol class="example">
  <b>序数 `omega` 的一些运算性质</b>
  <li>设 `alpha lt omega`, 则
    <span class="formula">
      `alpha + omega = omega`,
      `quad alpha gt 0 rArr alpha * omega = omega`,
      `quad alpha gt 1 rArr alpha^omega = omega`.
    </span>
  </li>
  <li>序数的加法和乘法满足结合律, 但交换律一般不成立, 例如
    `1 + omega = omega` 是一个极限序数, 但 `omega + 1` 是一个后继序数.
    乘法同理: `2 * omega = omega`, 但 `omega * 2 = omega + omega`.
  </li>
</ol>

<ol class="corollary">
  <b>序数加法的性质</b> 对任意序数 `alpha`:
  <li>零元: `0 + alpha = alpha`.</li>
  <li>`beta gt gamma iff alpha + beta gt alpha + gamma`.</li>
  <li>左消去律: `beta = gamma iff alpha + beta = alpha + gamma`.</li>
  <li>`beta gt gamma rArr beta + alpha ge gamma + alpha`.</li>
</ol>

<ol class="proof enum">
  <li>
    <ol>
      使用超穷递归证明:
      <li>`alpha = 0` 时, 结论成立;</li>
      <li>若 `0 + alpha = alpha`, 则 `0 + alpha^+` `= (0 + alpha)^+` `= alpha^+`;</li>
      <li>若 `alpha` 为极限序数, 且对一切 `xi lt alpha` 有 `0 + xi = xi`,
        则 `0 + alpha` `= "sup"{0 + xi: xi lt alpha}` `= "sup"{xi: xi lt alpha}`
        `= alpha`.
      </li>
    </ol>
  </li>
  <li>
    <ol>先证 `rArr`. 对 `beta` 归纳:
      <li>`beta = 1` 时, 必有 `gamma = 0`, 结论成立;</li>
      <li>假设 `beta gt gamma rArr alpha + beta gt alpha + gamma`, 考虑 `beta^+ gt gamma`,
        若 `gamma = beta`, 显然成立 `alpha + beta^+ gt alpha + gamma`;
        若 `gamma lt beta`, 由归纳假设 `alpha + beta^+ gt alpha + beta gt alpha + gamma`.
      </li>
      <li>假设 `beta` 为极限序数, 且结论对一切 `xi lt beta` 成立.
        任取 `gamma lt beta`,
        则由上确界性质 `alpha + beta` `= "sup"{alpha + xi: xi lt beta}` `ge alpha + gamma`.
        为了将上式加强为严格的不等式, 注意到 `beta` 为极限序数, 所以 `gamma^+
        lt beta`, 因此 `alpha + beta ge alpha + gamma^+ gt alpha + gamma`.
      </li>
    </ol>
    再证 `lArr`. 假设 `alpha + beta gt alpha + gamma`, 那么不能有 `beta = gamma`, 否则
    `alpha + beta = alpha + gamma`; 也不能有 `beta lt gamma`, 否则 `alpha + beta lt alpha + gamma`.
    所以 `beta gt gamma`.
  </li>
  <li>`rArr` 显然; 下证 `lArr`. 假设 `alpha + beta = alpha + gamma`, 那么不能有 `beta lt gamma`,
    否则 `alpha + beta lt alpha + gamma`; 同理不能有 `beta gt gamma`, 所以 `beta = gamma`.
  </li>
  <li>
    <ol>设 `beta gt gamma`, 对 `alpha` 归纳:
      <li>`alpha = 0` 时显然成立;</li>
      <li>设结论对 `alpha` 成立, 即 `beta + alpha ge gamma + alpha`,
        下证 `beta + alpha^+ ge gamma + alpha^+`.
        若 `beta + alpha = gamma + alpha`, 则结论已经成立. 若 `beta + alpha gt gamma + alpha`,
        则不可能有 `beta + alpha^+ lt gamma + alpha^+`, 否则两边取上确界得到
        `beta + alpha le gamma + alpha`, 矛盾.
      </li>
      <li>设 `alpha` 是极限序数, 且结论对一切 `xi lt alpha` 成立:
        `beta + xi ge gamma + xi`.
        两边取上确界就得到 `beta + alpha ge gamma + alpha`.
      </li>
    </ol>
  </li>
</ol>

<p class="remark">
  序数加法一般不满足右消去律, 比如 `1 + omega = 2 + omega = omega`.
</p>

<ol class="corollary">
  <li>若 `beta gt 0`, 则 `beta` 是极限序数当且仅当 `alpha + beta` 是极限序数.</li>
  <li>若 `beta gt 0`, 则
    <span class="formula">
      `alpha + "sup"{xi: xi lt beta}` `= "sup"{xi: xi lt alpha + beta}`.
    </span>
    进一步当 `beta` 是极限序数时, 它们都等于 `"sup"{alpha + xi: xi lt beta}`.
  </li>
</ol>

<ol class="proof enum">
  <li>设 `beta = gamma^+` 是后继, 于是 `alpha + beta = (alpha + gamma)^+` 也是后继.
    现在设 `beta` 是极限序数,
    下证 `alpha + beta` 是极限序数. ??
    <!--
    则 `alpha + beta` `= "sup"{alpha + xi: xi lt beta}`
    `= "sup"{xi: xi lt alpha + beta}`,
    因此 `alpha + beta` 也是极限序数.
    -->
  </li>
  <li>
    <ol>
      <li>若 `beta = gamma^+`, 则 `"sup" beta = gamma`. 于是
        <span class="formula">
          `alpha + beta`
          `= alpha + gamma^+`
          `= (alpha + gamma)^+`
          `= (alpha + "sup"beta)^+`.
        </span>
        两边同时取上确界得到 `alpha + "sup"beta` `= "sup"(alpha + beta)`.
      </li>
      <li>
        若 `beta` 是极限序数, 则 `"sup"beta = beta`, 由定义
        <span class="formula">
          `alpha + "sup" beta`
          `= alpha + beta`
          `= "sup"{alpha + xi: xi lt beta}`.
        </span>
        又由 3. 知 `alpha + beta` 也是极限序数, `alpha + beta = "sup"(alpha + beta)`.
      </li>
    </ol>
    <!--
      记 `S = {xi: xi lt alpha + beta}`, `T = {alpha + xi: xi lt beta}`. 任取
      `alpha + xi in T`, 因为 `xi lt beta`, 由 2. 有 `alpha + xi lt alpha + beta`, 所以 `T sube S`,
      `"sup"T le "sup"S`.
      反向的不等式 `"sup"S le "sup"T` ??
    -->
  </li>
</ol>

<p class="theorem">
  <b>加法结合律<b> `(alpha + beta) + gamma = alpha + (beta + gamma)`.
</p>

<ol class="proof">
  对 `gamma` 归纳:
  <li>`gamma = 0` 时结论成立;</li>
  <li>设结论对 `gamma` 成立, 则对 `gamma^+` 有
    <span class="formula align">
      `(alpha + beta) + gamma^+`<br>
      `= ((alpha + beta) + gamma)^+`<br>
      `= (alpha + (beta + gamma))^+`<br>
      `= alpha + (beta + gamma)^+`<br>
      `= alpha + (beta + gamma^+)`.
    </span>
  </li>
  <li>若 `gamma` 是极限序数, 且对一切 `xi lt gamma` 结论成立, 则
    <span class="formula align">
      `(alpha + beta) + gamma`<br>
      `= "sup"{(alpha+beta) + xi: xi lt gamma}`<br>
      `= "sup"{alpha + (beta+xi): xi lt gamma}`<br>
      `overset (??) = alpha + "sup"{beta + xi: xi lt gamma}`<br>
      `= alpha + (beta + gamma)`.
    </span>
  </li>
</ol>

<p class="theorem">
  <b>序数的减法</b>
  设序数 `beta le alpha`, 则存在唯一序数 `gamma` 使得 `beta + gamma = alpha`.
  于是可记 `alpha - beta := gamma`.
</p>

<ol class="proof enum">
  <li>
    存在性.
    `beta = alpha` 时取 `gamma = 0` 即可. 下设 `alpha gt beta ge 0`, 对 `alpha` 使用超穷递归:
    <ol>
      <li>若对序数 `alpha` 结论成立, 则对序数 `alpha^+` 和任意 `beta lt alpha^+`
        (即 `beta le alpha`) 有
        <span class="formula">
          `beta + gamma^+` `= (beta + gamma)^+` `= alpha^+`.
        </span>
      </li>
      <li>若 `alpha` 是极限序数, 且对一切 `xi lt alpha` 结论成立, 则对任意 `beta lt alpha`,
        <span class="formula">
          `beta + "sup"{gamma: beta + gamma = xi, xi lt alpha}`
          `overset (??) = "sup"{beta + gamma: beta + gamma = xi, xi lt alpha}`
          `= "sup"{xi: xi lt alpha}`
          `= alpha`.
        </span>
      </li>
    </ol>
  </li>
  <li>唯一性. 这等价于序数加法的左消去律.</li>
</ol>

<h2>选择公理</h2>

<p>[来自李文威《代数学方法》]
[参考 <a href="https://zhuanlan.zhihu.com/p/482203007" target="_blank">芷雨Chira@知乎</a>]
</p>

<p class="remark">
  在定义自然数集时, 我们用公理规定 "存在归纳集", 然后从中取出了一个归纳集
  `A`. 一般地, 给定有限个非空集合, 我们可以分别从中取出一个元素,
  作为它所在集合的代表. 然而, 当这样的非空集合有无限个时, 以上做法失效:
  因为公理和推理规则只能应用有限次. 一个自然的想法是, 对于无限个非空集合,
  也应能取出它们的代表元, 这就是选择公理.
</p>

<p class="axiom" id="axiom-choice">
  <b>选择公理</b>
  设集合 `X` 的每个元素皆非空, 则存在函数 `g: X to uuu X` 使得
  `AA x in X`, `g(x) in x`.
  这个函数称为选择函数.
</p>

<p class="theorem">
  对任意良序集 `P`, 存在唯一的序数 `alpha` 与它同构.
</p>

<p class="proof">
  不妨设 `P != O/`, 因为 `P` 是集合, 然而不存在无所不包的集合, 故可选取 `u !in P`.
  下面利用超穷递归定义一族元素 `A_alpha`, 其中 `alpha in bb(On)`:
  <br>
  首先由于 `P` 是良序集, 可以令 `A_0 := min(P)`, 这里 `min` 表示取出一个极小元.
  对任意序数 `alpha`, 记 `P_alpha := { A_beta: beta lt alpha }`, 对应于 `alpha` 的前段.
  递归定义
  <span class="formula">
    `A_alpha := {
        min(P - P_alpha), if P_alpha subne P;
        u, if P_alpha = P;
    :}`
  </span>
  由于 `P` 是集合, 必存在最小序数 `theta` 使得 `A_theta = u`, 否则 `bb(On)` 可以嵌入 `P`, 引起矛盾.
  于是 `A_alpha mapsto alpha` 是 `P` 到 `{beta: beta lt theta} = theta` 之间的同构.
</p>

<p class="remark">
  我们称 `P` 的<b>序型</b>是 `alpha`.
  因此序数是良序集的代表, 借助序数我们可以了解良序集的结构.
</p>

<p>下面的良序定理和 Zorn 引理是选择公理的等价命题:</p>

<p class="theorem">
  <b>Zermelo 良序定理 (1904)</b>
  对任意集合 `S`, 都存在 `S` 上的二元关系 `R`, 使得 `R` 是 `S` 上的良序.
</p>

<p class="proof">
  事实上, 只要把证明良序集与某个序数同构时的函数 `min`
  换成选择公理赋予我们的选择函数 `g`, 就得到 `S` 与某个序数 `theta` 之间的双射,
  从而导出 `S` 上的良序.
</p>

<ol class="theorem">
  <b>Zorn 引理</b>
  设 `P` 为非空偏序集, 它的全序子集称为<b>链</b>. 我们有:
  <li>若 `P` 中每个链都有上界, 则 `P` 有极大元;</li>
  <li>若 `P` 中每个链都有下界, 则 `P` 有极小元.</li>
</ol>

<ol class="proof">
  只证 1. 反设 `P` 不含极大元. 取 `A_0 in P`, 运用超穷递归定义 `A_alpha` 如下:
  设 `P_alpha := {A_beta: beta lt alpha}` 已经被定义, 且满足 `gamma lt beta rArr A_gamma lt A_beta`.
  于是 `P_alpha` 是 `P` 的一条链.
  <li>若 `alpha = gamma + 1`, 由于 `P` 无极大元, 故可以选取 `A_alpha in P` 使得 `A_alpha gt A_gamma`.
  </li>
  <li>若 `alpha` 为极限序数, 由题设, 链 `P_alpha` 有上界, 故可以选取一个上界 `A_alpha`.
    我们证明对任意 `beta lt alpha` 有 `A_beta lt A_alpha`.
    事实上若存在一个 `A_beta = A_alpha`,
    则其后继 `A_(beta^+) gt A_beta = A_alpha`, 与 `A_alpha` 是 `P_alpha` 的上界矛盾.
  </li>
  上述步骤中发生了无数次选取的操作, 这由选择公理保证.
  由上述构造知真类 `bb(On)` 可以嵌入 `P`, 从而矛盾.
</ol>

<script src="../../js/note.js?type=math"></script>
</body>
</html>
