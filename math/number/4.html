<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8" />
  <title>二次剩余</title>
  <link rel="stylesheet" type="text/css" href="../../css/note.css" />
</head>
<body>

<h2>二次剩余的定义</h2>

<p class="definition">
  设 `m` 为正整数, `(a, m) = 1`, 若同余方程
  <span class="formula">
    `x^2 -= a (mod m)`
  </span>
  有解, 则称 `a` 为 `m` 的<b>二次剩余</b> (或 `a` 是模 `m` 的平方数, `a`
  模 `m` 存在平方根). 否则, `a` 为 `m` 的<b>二次非剩余</b>.
</p>

<p class="remark">
  若 `x` 是 `a` 模 `m` 的平方根, 则任意
  `x + k m (k in ZZ)` 也是平方根.
  因此讨论二次剩余时, 只需考虑
  <span class="formula">
    `a in ZZ_m^** := { a in ZZ_m : (a, m) = 1 }`.
  </span>
  我们对同余的 `a` 不作区分, 在计算二次剩余的个数时,
  也把同余的数视为同一个.
</p>

<p class="remark">
  下文重点讨论 `m` 为奇素数 `p` 的情形.
  此时 `a in ZZ_p^** = { bar 1, bar 2, cdots, bar (p-1) }`,
  换言之, `p !| a`.
</p>

<p class="proposition">
  设 `p` 为奇素数, `a in ZZ_p^**`, 则 `a` 模 `p` 的平方根有 0 个或 2 个.
</p>

<p class="proof">
  先证平方根的数目不为 1.
  设 `x` 是 `a` 模 `p` 的一个平方根, 易知 `-x` 也是一个平方根.
  但 `x !-= -x (mod p)`, 否则 `p | 2x` `rArr p | x` `rArr p | x^2`
  `rArr p | a`,
  矛盾.<br>
  下证平方根的数目不多于 2. 设 `x^2 -= y^2 -= a (mod p)`, 则
  <span class="formula">
    `(x-y)(x+y) -= 0 (mod p)`,
  </span>
  这蕴含 `p | x-y` 或 `p | x+y`, 即 `x -= +- y (mod p)`.
</p>

<p class="proposition">
  设 `p` 为奇素数, 则在集合 `ZZ_p^**` 中,
  模 `p` 的二次剩余和非剩余各占一半.
</p>

<p class="proof">
  `ZZ_p^**` 的元素可以写为
  <span class="formula">
    `+-1, +-2, cdots, +-(p-1)//2`,
  </span>
  恰好对应于
  <span class="formula">
    `1^2, 2^2, cdots, ((p-1)/2)^2`.
  </span>
  由上一个命题知道, 若 `x^2 -= y^2 (mod p)`, 则 `x -= +- y (mod p)`.
  故以上 `(p-1)//2` 个数两两不相等, 即为模 `p` 的所有二次剩余.
</p>

<p class="proposition">
  <b>用原根判定二次剩余</b>
  设 `p` 为奇素数, 取 `p` 的原根 `r`, 则
  <span class="formula">
    `ZZ_p^** = {1, r, cdots, r^(p-2)}`.
  </span>
  其中 `a = r^n` 是 `p` 的二次剩余当且仅当 `n` 是偶数.
  特别地, 原根 `r` 为 `p` 的二次非剩余. 同时,
  我们再次验证了二次剩余和非剩余各占一半的事实.
</p>

<p class="proof">
  设 `n` 是偶数, 则 `r^(n/2)` 是 `a = r^n` 的平方根.
  现在设 `x` 是 `a` 的一个平方根, 于是
  <span class="formula">
    `n = log_r a -= log_r x^2 -= 2 log_r x (mod varphi(p))`,
  </span>
  因此 `n` 是偶数.
</p>

<h2>Legendre 符号</h2>

<h3>二次剩余的判别法</h3>

<p class="definition">
  设 `p` 为奇素数, `a in ZZ_p^**`, 定义 Legendre 符号为
  <span class="formula">
    `(a/p) = { 1, if a 是 p 的二次剩余;
    -1, if a 是 p 的二次非剩余 :}`
  </span>
</p>

<p class="corollary">
  <b>原根判别法</b> `(r/p) = -1`, `r` 为 `p` 的原根.
</p>

<p class="theorem">
  <b>Euler 判别法</b> `(a/p) -= a^n (mod p)`, `n = (p-1)//2`.
</p>

<ol class="proof">
  <li>设 `(a/p) = 1`, `x` 为 `a` 模 `p` 的平方根, 由 Fermat 小定理,
    <span class="formula">
      `a^((p-1)//2) -= x^(p-1) -= 1 (mod p)`.
    </span>
  </li>
  <li>设 `(a/p) = -1`. 对每个 `x in ZZ_p^**`, 存在唯一的 `y in ZZ_p^**`
    使得 `x y -= a (mod p)`, 因为 `a` 是模 `p` 的二次非剩余, 所以 `x !=
    y`. 因此, 集合 `ZZ_p^**` 可以划分为 `(p-1)//2` 对, 每一对的乘积为 `a`.
    由 Wilson 定理,
    <span class="formula">
      `a^((p-1)//2) -= (p-1)! = -1 (mod p)`.
    </span>
  </li>
</ol>

<p class="corollary">
  Legendre 符号 `(a/p)` 是关于 `a` 的积性函数:
  <span class="formula">
    `(a/p)(b/p) = ((a b)/p)`,
  </span>
  特别地 `(a^2/p) = 1`.
</p>

<p class="theorem">
  <b>Gauss 判别法</b>
  `(a/p) = (-1)^s`, `s` 是
  <span class="formula">
    `A = {a, 2a, cdots, n a}`
  </span>
  中模 `p` 的绝对最小剩余为负的个数, `n = (p-1)//2`.
</p>

<ol class="proof">
  <li>设 `A` 中元素的绝对最小剩余为 `a_1, a_2, cdots, a_n`.
  由于 `A` 中元素均不是 `p` 的倍数, 因此这些余数只能取值
  `+-1, +-2, cdots, +-n`. 下证 `|a_1|, |a_2|, cdots, |a_n|`
  两两不同, 从而恰好构成 `1` 到 `n` 的一个排列.
  </li>
  <li>若存在 `1 le i, j le n` 使得 `i a -= j a (mod p)`,
    则 `i -= j (mod p)`. 若 `i a -= - j a (mod p)`, 则 `p | i + j`,
    然而 `2 le i + j le 2n lt p`, 这是不可能的.
    因此, `|a_1|, |a_2|, cdots, |a_n|` 两两不同.
  </li>
  <li>将这些数相乘得到
    <span class="formula">
      `n! = prod_(i=1)^n |a_n|`
      `= (-1)^s prod_(i=1)^n a_n`
      `-= (-1)^s prod_(i=1)^n (i a)`
      `-= (-1)^s a^n n!` `(mod p)`,
    </span>
    即 `a^n -= (-1)^s (mod p)`. 再由 Euler 判别法即得结论.
  </li>
</ol>

<h3>-1 和 2 何时是二次剩余</h3>

<p class="example">
  `((-1)/p) -= p (mod 4)`.<br>
  换言之, 设 `p` 为奇素数, 方程 `x^2 + 1 -=
  0 (mod p)` 有解当且仅当 `p` 形如 `4n+1`. 比如, `5 = 2^2+1`,
  `2*13 = 5^2 + 1`, `17 = 4^2 + 1` 等.
</p>

<ol class="proof">
  `p = 4n+1` 时, `((-1)/p) = (-1)^(2n) = 1`;<br>
  `p = 4n-1` 时, `((-1)/p) = (-1)^(2n-1) = -1`.
</ol>

<p class="example">
  `(2/p) = { 1, p -= +-1 (mod 8); -1, p -= +-3 (mod 8) :}`.
</p>

<h2>二次互反律</h2>

<script src="../../js/note.js?type=math"></script>
</body>
</html>
