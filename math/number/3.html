<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <title>指数与原根</title>
    <link rel="stylesheet" type="text/css" href="../../css/note.css" />
</head>
<body>

<h2>指数的定义与性质</h2>

<p class="definition">
    设 `m` 为正整数, `(a, m) = 1`, 称满足
    <span class="formula">
        `a^d -= 1 (mod m)`
        <span class="label" id="for-index"></span>
    </span>
    的最小正整数 `d` 为 `a` 对模 `m` 的<b>指数</b>或<b>阶</b>,
    记为 `"ord"_m a`. 下文涉及到指数 `"ord"_m a` 时,
    总假定 `(a, m) = 1`.
</p>

<p class="proposition">
    满足<a class="ref" href="#for-index"></a>的正整数 `d` 是存在的,
    且 `"ord"_m a lt m`.
</p>

<p class="proof">
    `m = 1` 的情形是平凡的, 下设 `m gt 1`,
    因为 `(a, m) = 1`, 可设
    <span class="formula">
        `a^i -= r_i (mod m)`,
        `quad 0 lt r_i lt m`,
        `quad i = 0, 1, cdots, m-1`,
    </span>
    `m` 个余数 `r_i` 只能取 `m-1` 个值, 由鸽巢原理, 必有两个余数相等,
    设 `a^i -= a^j (mod m)`, `i gt j`. 同余式两边同乘 `a^-j` 得
    <span class="formula">
        `a^(i-j) -= 1 (mod m)`.
    </span>
    取 `d = i-j` 即得结论.
</p>

<p> 事实上 `"ord"_m a` 的上界可进一步降低,
    这就是下面的 Euler-Fermat 定理:
</p>

<p class="theorem">
    <b>Euler-Fermat 定理</b>
    设 `m` 为正整数, `(a, m) = 1`, 则
    <span class="formula">
        `a^(varphi(m)) -= 1 (mod m)`.
    </span>
    特别当 `m` 为素数 `p` 时, 上式即 Fermat 小定理 `a^(p-1) -= 1 (mod p)`.
</p>

<p class="proof">
    设 `{r_i}_(i=1)^(varphi(m))` 是模 `m` 的既约剩余系, 由
    `(a, m) = 1` 知, `{a r_i}_(i=1)^(varphi(m))` 也是模 `m`
    的既约剩余系. 从而
    <span class="formula">
        `prod r_i -= prod (a r_i) -= a^(varphi(m)) prod r_i` `(mod m)`,
    </span>
    上式两边同乘 `prod r_i` 关于模 `m` 的逆就得到结论.
</p>

<p class="definition">
    由 Euler-Fermat 定理, `"ord"_m a le varphi(m)`.
    当等号成立时, 称 `a` 是模 `m` 的<b>原根 (primitive root)</b>.
</p>

<p class="remark">
    从群论的观点, 模 `m` 的既约剩余系构成一个乘法群, `"ord"_m a` 就是
    `a` 在群中的阶. 若 `a` 为原根, 则 `a` 的阶等于群的阶 `varphi(m)`,
    此时 `a` 是群的生成元, 既约剩余系具有循环群的简单结构.
</p>

<ol class="corollary" id="cor-index">
    设 `(a, m) = 1`, `"ord"_m a = delta`.
    <li>`a^n -= 1 (mod m)` 当且仅当 `delta | n`.
        因此 `delta | varphi(m)`, 且 `a^n` (`n = 0, 1, 2, cdots`)
        模 `m` 的余数以指数 `delta` 为周期.
    </li>
    <li>若 `a^i -= a^j (mod m)`, 则 `i -= j (mod delta)`.
        因此, 在一个周期内, `a^n` (`n = 0, 1, cdots, delta-1`)
        模 `m` 的 `delta` 个余数两两不同.
        特别当 `a` 是原根时, `a^n` (`n = 0, 2, cdots, varphi(m)-1`)
        构成模 `m` 的既约剩余系.
    </li>
</ol>

<ol class="proof">
    这里给出利用同余性质的证明. 也可以用基本的带余除法和整除性质来证,
    但较繁琐.
    <li>只证必要性. 设 `n = delta q + r` (`0 le r lt delta`),
        若 `a^n -= 1 (mod m)`, 同余式两边同乘 `a^(-delta q)` 得
        `a^r -= 1 (mod m)`, 再由 `delta` 的最小性知 `r = 0`.
    </li>
    <li>不妨取 `0 le j le i lt delta`, 则
        `a^i -= a^j (mod m) iff a^(i-j) -= 1 (mod m)`, 由 `delta`
        的最小性知 `i-j = 0`, 即 `i -= j (mod delta)`.
    </li>
</ol>

<ol class="example">
    讨论模 `m = 2^n` 的指数与原根.
    <li>模 `m = 1, 2, 4` 时有原根;</li>
    <li>`n ge 3` 时, 模 `m = 2^n` 无原根.
        此时对任意奇数 `a` 有
        <span class="formula">
            `a^(2^(n-2)) -= 1 (mod 2^n)`;
        </span>
    </li>
    <li>`n ge 3` 时, `"ord"_m 5 = 2^(n-2)`.
        这时数字 5 是原根这一角色的一个 "替代品".
    </li>
</ol>

<ol class="proof">
    <li>`n lt 3` 的情形列表如下:
    <table>
        <tr>
            <th>`n`</th>
            <th>`m`</th>
            <th>`varphi(m)`</th>
            <th>`"ord"_m 1`</th>
            <th>`"ord"_m(-1)`</th>
            <th>原根</th>
        </tr>
        <tr>
            <td>0</td>
            <td>1</td>
            <td>1</td>
            <td>1</td>
            <td>1</td>
            <td>平凡情形, 所有整数都是原根</td>
        </tr>
        <tr>
            <td>1</td>
            <td>2</td>
            <td>1</td>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
        <tr>
            <td>2</td>
            <td>4</td>
            <td>2</td>
            <td>1</td>
            <td>2</td>
            <td>-1</td>
        </tr>
    </table>
    </li>
    <li>对 `n` 进行归纳. 设 `a = 2t+1`, 则 `n = 3` 时
        <span class="formula">
            `a^2 = 4t(t+1) + 1 -= 1 (mod 2^3)`,
        </span>
        结论成立. 假设结论对整数 `n ge 3` 成立, 则对 `n+1` 有
        <span class="formula">
            `2^(n+1) | (a^(2^(n-2))-1)(a^(2^(n-2))+1)`
            `= a^(2^(n-1)) - 1`,
        </span>
        结论也成立.
        由于 `varphi(2^n) = 2^(n-1) gt 2^(n-2)`, 故此时无原根.
    </li>
    <li>2. 中已经证明 `"ord"_m 5 | 2^(n-2)`, 因而只需证 `"ord"_m 5 !|
        2^(n-3)`, 即证
        <span class="formula">
            `5^(2^(n-3)) !-= 1 (mod 2^n)`, `quad n ge 3`.
        </span>
        对 `n` 进行归纳. `n=3` 时结论成立. 假设结论对整数 `n ge 3` 成立,
        则 `n+1` 时, 由于
        <span class="formula">
            `5^(2^(n-3)) -= 1 (mod 2^(n-1))`, `quad n ge 3`.
        </span>
        可设 `5^(2^(n-3)) = 2^(n-1) s + 1`, 于是
        <span class="formula">
            `5^(2^(n-2)) = (2^(n-1) s + 1)^2`
            `= 2^n s(2^(n-2) s + 1) + 1`.
        </span>
        由归纳假设, `2 !| s`, 因此 `5^(2^(n-2)) !-= 1 (mod 2^(n+1))`.
    </li>
</ol>

<ol class="property">
    指数的若干计算性质.
    <li>若 `a, b` 模 `m` 同余, 则它们的指数相等.
        因此, 指数是既约剩余系中的性质, 两个数只要模 `m` 同余,
        就可以视作是等价的.
    </li>
    <li>设 `a^-1` 是 `a` 模 `m` 的逆, 则它与 `a` 的指数相等;</li>
    <li>`n | m rArr` `"ord"_n a | "ord"_m a`;</li>
    <li>若 `(m, n) = 1`, 则 `"ord"_(m n) a = ["ord"_m a, "ord"_n a]`;
    </li>
    <li>`"ord"_m(a b) = "ord"_m a "ord"_m b` 当且仅当 `("ord"_m a,
        "ord"_m b) = 1`;
    </li>
</ol>

<ol class="proof">
    <li>只需注意对任意 `k ge 0`, `a^k -= b^k (mod m)`.</li>
    <li>只需注意对任意 `k ge 0`, `a^k -= 1 (mod m)`
        当且仅当 `a^-k -= 1 (mod m)`.
    </li>
    <li>只需注意 `n | m` 时, `a^delta -= 1 (mod m) rArr
        a^delta -= 1 (mod n)`;
    </li>
    <li>分别记 `"ord"_m a = M`, `"ord"_n a = N`, `"ord"_(m n) a = delta`.
      由 3. 得 `[M, N] | delta`. 另一方面, 有
        <span class="formula">
            `a^([M,N]) -= 1 (mod m)`,
            `quad a^([M,N]) -= 1 (mod n)`,
        </span>
        由 `(m, n) = 1` 得 `a^([M,N]) -= 1 (mod m n)`, 因此 `delta
        | [M,N]`.
    </li>
    <li>分别记 `a, b, a b` 的指数为 `A, B, delta`. 先证必要性:
        我们有 `(a b)^([A,B]) -= 1 (mod m)`, 故 `A B = delta | [A,B]`.
        这推出 `(A, B) = 1`.<br/>
        再证充分性. 一方面有
        <span class="formula">
            `(a b)^(A B) -= 1 (mod m)`,
        </span>
        故 `delta | A B`; 另一方面
        <span class="formula">
            `a^(delta B) = a^(delta B) b^(delta B) -= (a b)^(delta B) -= 1 (mod m)`,
        </span>
        故 `A | delta B`, 再由 `(A, B) = 1` 得 `A | delta`;
        同理 `B | delta`. 再次由 `(A, B) = 1` 得 `A B | delta`.
    </li>
</ol>

<p class="remark">
    由计算性质4, 求模 `m` 的指数, 只需把 `m` 进行标准分解
    `m = prod p_i^(n_i)`, 就有
    <span class="formula">
        `"ord"_m a = ["ord"_(p_1^(n_1)) a, cdots, "ord"_(p_r^(n_r)) a]`.
    </span>
</p>

<ol class="theorem">
    <b>元素幂的阶数公式</b> 设 `n ge 0`, `"ord"_m a = delta`, 则
    <span class="formula">
        `"ord"_m(a^n) = delta//(n, delta)`;
    </span>
    特别地,
    <li>若 `delta = s t`, 则 `"ord"_m(a^s) = t`;</li>
    <li>`"ord"_m(a^n) = "ord"_m a` 当且仅当 `(n, delta) = 1`.
        于是模 `m` 的既约剩余系中, 至少有
        <span class="formula">
            `a^n`, `quad 0 le n lt delta`, `(n, delta) = 1`
        </span>
        这 `varphi(delta)` 个数的指数等于 `delta`.
    </li>
</ol>

<p class="proof">
    记 `"ord"_m(a^n) = k`, `(n, delta) = d`. 一方面,
    <span class="formula">
        `(a^n)^(delta // d) = (a^delta)^(n//d) -= 1 (mod m)`,
    </span>
    故 `k | delta/d`; 另一方面
    <span class="formula">
        `a^(n k) = (a^n)^k -= 1 (mod m)`,
    </span>
    故 `delta | n k`, 即 `delta/d | n/d k`.
    因为 `(delta/d, n/d) = 1`, 所以 `delta/d | k`.
    综上有 `k = delta/d`.
</p>

<ol class="theorem">
  <b>给定阶元素的存在性定理</b>
  <li>若 `(m, n) = 1`, 则对任意 `a, b`, 存在 `c` 使得
    `"ord"_(m n) c = ["ord"_m a, "ord"_n b]`.
  </li>
  <li>对任意 `a, b`, 存在 `c` 使得
    `"ord"_m c = ["ord"_m a, "ord"_m b]`.
  </li>
</ol>

<ol class="proof">
    <li>因为 `(m, n) = 1`, 由孙子定理, 同余方程组
        <span class="formula">
            `x -= a (mod m)`, `quad x -= b (mod n)`
        </span>
        存在唯一解 `x -= c (mod m n)`.
        因为 `c` 和 `a, b` 分别关于模 `m, n` 同余, 所以
        `"ord"_m c = "ord"_m a`, `"ord"_n c = "ord"_n b`.
        再由计算性质4 即得结论.
    </li>
    <li>分别记 `A = "ord"_m a`, `B = "ord"_m b`, `eta = [A, B]`. 作分解
        <span class="formula">
            `A = a_1 a_2`, `quad B = b_1 b_2`,<br/>
            其中 `(a_2, b_2) = 1`, `quad a_2 b_2 = eta`.
        </span>
        这样的分解是可行的: 设素因子 `p` 在 `eta` 中的次数为 `n`,
        则 `p` 在 `A, B` 中的次数较高的那个也等于 `n`.
        对 `eta` 的每个素因子都如此分类即可得到 `a_2, b_2`.<br/>
        现在由阶数公式,
        <span class="formula">
            `"ord"_m(a^(a_1)) = a_2`, `quad "ord"_m(b^(b_1)) = b_2`,
        </span>
        取 `c = a^(a_1) b^(b_1)`, 由计算性质5,
        <span class="formula">
            `"ord"_m c = "ord"_m(a^(a_1) b^(b_1)) = a_2 b_2 = eta`.
        </span>
    </li>
</ol>

<h2>原根存在的充要条件</h2>

<p class="theorem">
    模 `m` 有原根的充要条件是
    <span class="formula">
        `m = 1, 2, 4, p^n, 2p^n`.
    </span>
    其中 `p` 是奇素数, `n ge 1`.
</p>

<p class="proof">
    先证必要性, 充分性将在下文分几个定理完成证明.
    ??
</p>

<p class="example">
    我们知道, `1//7 = 0. dot 1 4285 dot 7`, 其循环节恰有 `7-1 = 6` 位.
    在 100 以内, 除 2 以外, 满足 `1//n` 的循环节恰有 `n-1`
    位这一性质的正整数 `n` 有:
    <span class="formula">
        7, 17, 19, 23, 29, 47, 59, 61, 97.
    </span>
    它们都是素数以外, 还有什么共同特点?
</p>

<p class="solution">
    共同特点是: 10 是模 `n` 的原根.
    原因是若 `10^d -= 1 (mod n)`, 即 `n | 10^d - 1`, 则分数 `1//n`
    可以化为循环节 `d` 位的循环小数. 如 `10^6 -= 1 (mod 7)`, 则
    <span class="formula">
        `1/7 = 142857/999999 = 0. dot 1 4285 dot 7`.
    </span>
    又如 `10^6 -= 1 (mod 13)`, 则
    <span class="formula">
        `1/13 = 076923/999999 = 0. dot 0 7692 dot 3`.
    </span>
    因此, 当 `(10, n) = 1` 时, 循环节的长度就是 10 模 `n` 的指数.
    要使循环节恰有 `n-1` 位, 就要求 10 模 `n` 的指数等于 `n-1`;
    这当且仅当 `n` 是素数, 且 10 是模 `n` 的原根.
</p>

<p class="example">
  [<a href="https://www.bilibili.com/video/BV1SK4y1974A">manim 短篇 离散猫变换</a>]
  设 `bm A = [2, 1; 1, 1]`, `bm I = [1, 0; 0, 1]`.
  依次取 `m = 11, 59, 2855`,
  求 `"ord"_m bm A`, 即求最小的正整数 `n` 使得
  <span class="formula">
    `bm A^n -= bm I (mod m)`.
  </span>
</p>

<ol class="solution">
  `bm A` 是对称矩阵, 因此可以对角化, 即存在模 `m` 可逆矩阵 `bm P` 使得
  <span class="formula">
    `bm A = bm P^-1 bm D bm P`,
    `quad bm D = [x, ; , y]`.
  </span>
  其中 `x, y` 是 `bm A` 模 `m` 的特征值.
  若 `bm A^n -= bm I (mod m)`, 必有 `bm D^n -= bm I (mod m)`, 即
  <span class="formula">
    `{ x^n -= 1; y^n -= 1 :} (mod m)`.
  </span>
  注意 `|bm A| = 1`, 所以不论 `m`
  取何值, `bm A` 总是非奇异的, 这蕴含 `x^n !-= 0, y^n !-= 0 (mod m)`,
  特别当 `m` 为素数时, 上面的方程组总是有解.
  <li>`m = 11` 时, 由 `x + y -= 3, x y -= 1(mod 11)`, 利用求根公式得
    <span class="formula">
      `x, y -= (3 +- sqrt 5)//2`
      `-= (3 +- 4) * 6`
      `= -2, 5 (mod 11)`
    </span>
    `mod 11` 下 `"ord" (-2) = "ord" 5 = 5`, 取最小公倍数得到
    `"ord"_11 bm A = 5`.
  </li>
  <li>`m = 59` 时特征值为 `(3 +- 8) * 30 -= -24, -32 (mod 59)`.
    从而 `"ord"_59 bm A` `= lcm("ord"(-24), "ord"(-32))`
    `= lcm(29, 29) = 29`.
  </li>
  <li>`m = 2855 = 5 * 571` 时, 模 `5` 的特征值为 `-1 (mod 5)` (2 重根),
    `"ord"_5 (-1) = 2`. 模 `571` 的特征值为 `(3 +- 24) * 286 -= 299, 275
    (mod 571)`, 且 `"ord"_571 299 = "ord"_571 275 = 285`.
    从而 `"ord"_2855 bm A = 2 * 285 = 570`.
  </li>
</ol>

<h2>分圆多项式</h2>

<p class="definition">
  设 `lambda in CC`, 若 `n` 是使得 `lambda^n = 1` 成立的最小正整数,
  则称 `lambda` 的阶为 `n`, 记为 `"ord"lambda = n`.
  <b>分圆多项式 (或割圆多项式)</b>定义为
  <span class="formula">
    `phi_n(x) = prod_("ord"lambda = n) (x - lambda)`.
  </span>
  `phi_n(x)` 的所有根称为 `n` 次<b>本原单位根</b>
  <span class="formula">
    `Theta_n = {"e"^(2pi"i"k//n) | (k, n) = 1 }`.
  </span>
  因此 `phi_n(x)` 的次数就等于 `|Theta_n| = varphi(n)`.
</p>

<p class="proposition">
  若 `lambda, mu` 是两个 `n` 次本原单位根, 则存在与 `n` 互素的整数 `m`
  使得 `mu = lambda^m`.
</p>

<p class="proof">
  记 `omega = "e"^(2pi"i"//n)`, `lambda = omega^j`, `mu = omega^k`,
  `(j, n) = (k, n) = 1`, 只需取 `m` 使得 `j m -= k (mod n)`, 就有
  `lambda^m = omega^(j m) = omega^k = mu`.
</p>

<p class="remark">
  本原单位根与原根的概念不同. 原根 `r` 可以生成整个既约剩余系 `1, r, r^2,
  cdots`, 而本原单位根无此性质.
</p>

<p class="proposition">
  `x^n-1 = prod_(d | n) phi_d(x)`.
</p>

<p class="proof">
  这个等式是对所有 `n` 次单位根按阶分类的结果.
  注意和整数的阶一样, 我们有 `lambda^n = 1 iff "ord"lambda | n`.
</p>

<p>尽管从定义看来不很显然, 但分圆多项式的系数都是整数!</p>

<p class="proposition">
  分圆多项式 `phi_n(x)` 是首 1 的整数系数多项式, 其常数项 `in {1, -1}`.
</p>

<p class="proof">
  首 1 性由定义立即看出. 对 `n` 进行归纳, `n=1` 时 `phi_1(x) = x-1`,
  结论成立. 假设结论对一切 `d lt n` 成立, 考虑 `n` 的情形, 有
  <span class="formula">
    `x^n - 1 = prod_(d | n) phi_d(x) = F(x) phi_n(x)`,
  </span>
  其中
  <span class="formula">
    `F(x) = sum_(j=0)^l a_j x^j`,
    `quad phi_n(x) = sum_(j=0)^(n-l) b_j x^j`,
  </span>
  由归纳假设, `a_0 in {1, -1}`, 比较系数得 `b_0 in {1, -1}`.
  又假定 `b_0, b_1, cdots b_(k-1)` 已被证实为整数, 比较两边 `x^k` 的系数知
  <span class="formula">
    `a_0 b_k + sum_(j=0)^(k-1) a_(k-j) b_j`
  </span>
  为整数, 因此 `a_0 b_k` 为整数, 从而 `b_k` 为整数.
</p>

<table class="col2">
  <tr>
    <th>`n`</th>
    <th>`phi_n(x)`</th>
    <th>`n`</th>
    <th>`phi_n(x)`</th>
  </tr>
  <tr>
    <td>1</td>
    <td>`x-1`</td>
    <td>6</td>
    <td>`x^2-x+1`</td>
  </tr>
  <tr>
    <td>2</td>
    <td>`x+1`</td>
    <td>7</td>
    <td>`x^6+x^5+x^4+x^3+x^2+x+1`</td>
  </tr>
  <tr>
    <td>3</td>
    <td>`x^2+x+1`</td>
    <td>8</td>
    <td>`x^4+1`</td>
  </tr>
  <tr>
    <td>4</td>
    <td>`x^2+1`</td>
    <td>9</td>
    <td>`x^6+x^3+1`</td>
  </tr>
  <tr>
    <td>5</td>
    <td>`x^4+x^3+x^2+x+1`</td>
    <td>10</td>
    <td>`x^4-x^3+x^2-x+1`</td>
  </tr>
</table>

<p>`n = 105` 时, 分圆多项式的系数中首次出现 `{1, -1, 0}` 以外的数:
  <span class="formula">
    `phi_105(x) = x^48+x^47+x^46-x^43-x^42- color(red)2 x^41-x^40-x^39+x^36+x^35+x^34`
    `+x^33+x^32+x^31-x^28-x^26-x^24-x^22-x^20+x^17+x^16+x^15+x^14+x^13`
    `+x^12-x^9-x^8-color(red)2 x^7-x^6-x^5+x^2+x+1`.
  </span>
</p>

<ol class="proposition">
  当 `n = p` (`p` 为素数) 或 `2p` (`p` 为奇素数) 时,
  分圆多项式的形式比较简单:
  <li>`phi_p(x) = sum_(k=0)^(p-1) x^k`;</li>
  <li>`phi_(2p)(x) = sum_(k=0)^(p-1) (-x)^k`.</li>
</ol>

<ol class="proof">
  <li>因为 `Theta_n = {"e"^(2pi"i"k//p) | (k, p) = 1}`
    `= {"e"^(2pi"i"k//p) | k = 1, cdots, p-1}`,
    所以 `phi_p(x) = (x^p-1)/(x-1)`.
  </li>
  <li>设 `p` 为奇素数. 下证 `lambda` 的阶为 `p` 当且仅当 `-lambda` 的阶为
    `2p`.<br>
    若 `"ord"lambda = p`, 容易验证 `(-lambda)^(2p) = 1`;
    又对任意 `d | 2p`, 有 `d = 1, 2, p, 2p`. 若 `(-lambda)^d = 1`, 则
    由于 `p` 是奇素数, `d` 只能等于 `2p`. 这指出 `-lambda` 的阶是
    `2p`.<br>
    反之若 `-lambda` 的阶为 `2p`, 则 `(-lambda)^p` 是 `1` 的因子, 只能是
    `-1`. 两边约去 `(-1)^p` 得 `lambda^p = 1`. 显然 `lambda^1` 不等于 `1`,
    因此 `lambda` 的阶为 `p`.
    <br>
    另一方面, `varphi(p) = varphi(2p) = p-1`, 这指出 `p` 次本原单位根和
    `2p` 次本原单位根一样多. 因此, 只要将 `phi_p(x)` 中的 `x` 换成 `-x`,
    就得到 `phi_(2p)(x)`.
  </li>
</ol>

<p class="proposition">
  分圆多项式在 `ZZ` 上不可约, 从而由 Gauss 引理, 在 `QQ` 上也不可约.
</p>

<ol class="proof">
  <li>反设 `phi_n(x) = g(x) h(x)`, 其中 `g, h` 是首 1 的, 次数 `ge 1`
    的整系数多项式, 且 `g` 不可约. 任取 `g` 的一根 `lambda` 和素数 `p !|
    n`, 下证 `lambda^p` 也是 `g` 的根.
  </li>
  <li>由分圆多项式定义, `lambda^p` 是 `phi_n(x)` 的根; 若它不是 `g` 的根,
    则它是 `h` 的根, 因此 `lambda` 是 `g(x)` 和 `h(x^p)` 的公共根.
    现在对 `p` 取模, 由 Fermat 小定理,
    <span class="formula">
      `h(x^p) -= h(x) (mod p)`,
    </span>
    即 `g` 和 `h` 在模 `p` 意义下有公共根.
    下证 `phi_n(x) = g(x) h(x)` 在模 `p` 意义下无重根, 从而引出矛盾.
  </li>
  <li>`phi_n(x)` 是 `x^n-1` 的因子, 故只需证 `f(x) = x^n-1` 模 `p`
    意义下无重根.  事实上, `(f(x), f'(x)) = (x^n-1, n x^(n-1)) = 1`,
    因此它无重根.
  </li>
  <li>综上有 `lambda^p` 是 `g` 的根.
    任取 `n` 次本原单位根 `lambda^m`, `(m, n) = 1`,
    作素因子分解 `m = prod p_i`, 则
    <span class="formula">
      `lambda^m = ((lambda^(p_1))^(p_2))^cdots`
    </span>
    也是 `g` 的根. 这就是说 `phi_n(x)` 的所有根都是 `g` 的根,
    从而 `phi_n(x) = g(x)` 是不可约多项式.
  </li>
</ol>

<p class="definition">
  <b>分圆域</b> 是多项式 `x^n - 1 in QQ[x]` 的分裂域 `QQ(Theta_n)`.
  显然, 将任一 `n` 次本原单位根加到 `QQ` 中都得到同一个分圆域.
  `Q(Theta_n) // QQ` 是 Galois 扩张, 扩张次数为 `varphi(n)`.
  分圆域的 Galois 群??
</p>

<script src="../../js/note.js?type=math"></script>
</body>
</html>
