<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8" />
  <title>李代数初步</title>
  <link rel="stylesheet" href="../../css/note.css"/>
</head>

<body>

<h2>导子与 Lie 括积</h2>

<p>[来自 <a href="https://zhuanlan.zhihu.com/p/144789716" target="_blank">给大一学生的 Lie 代数</a>]</p>

<p>
  在微积分中, "微分", 或 "求导" 是典型的线性运算:
  <span class="formula">
    `(k f + l g)' = k f' + l g'`,
  </span>
  它最具特色的性质就是乘积的求导公式
  <span class="formula">
    `(f g)' = f'g + f g'`.
  </span>
  我们将 "求导" 运算推广到线性空间中来, 首先要求线性空间中有定义 "乘积".
  事实上, 许多常见的线性空间都有定义乘积. 如 `bbb F[x]` 中的多项式乘法,
  `C^oo(a,b)` 中函数的逐点乘法, `bbb F^(n xx n)` 中的矩阵乘法, 乃至
  `"End"V` (`V` 上全体线性变换) 中线性变换间的乘法. 由此给出导子的定义:
</p>

<p class="definition">
  设 `V` 是定义了乘法的线性空间, 若 `V` 上线性变换 `D` 满足
  <span class="formula">
    `D(f g) = D(f) g + f D(g)`, `quad AA f, g in V`,
  </span>
  则称 `D` 是 `V` 的<b>导子</b>. `V` 中全体导子
  `"Der"V` 按线性变换的加法和数乘构成 `"End"V` 的线性子空间.
</p>

<p class="remark">
  对于线性空间 `V` 上的乘法, 我们不要求它可交换, 甚至也不要求它具有结合律,
  只要求它是满足封闭性的双线性映射 `V xx V to V` 即可:
  <span class="formula">
    `(k A + l B) C = k A C + l B C`,<br>
    `C (k A + l B) = k C A + l C B`.
  </span>
  这样的二元运算称为一个<b>代数</b>.
</p>

<p class="corollary">
  若 `A, B in "DerV`, 则 `A B - B A in "Der"V`.
</p>

<p class="proof">
  `AA f, g in V`,
  <span class="formula align">
    `(A B - B A) (f g)`<br>
    `= A B(f g) - B A(f g)`<br>
    `= A(B(f)g + f B(g)) - B(A(f)g + f A(g))`<br>
    `= A B(f)g + B(f)A(g) + A(f)B(g) + f A B(g)`<br>
    `quad - B A(f)g - A(f)B(g) - B(f)A(g) - f B A(g)`<br>
    `= (A B-B A)(f)g + f(A B-B A)(g)`.
  </span>
</p>

<p class="remark">
  这个 `A B - B A` 如此好用, 以至于有如下定义:
</p>

<p class="definition">
  设 `V` 是定义了代数的线性空间, `A, B in V`. 称
  <span class="formula">
    `[A, B] := A B - B A`
  </span>
  为 <b>Lie 括积</b>, 简称括积.
</p>

<ol class="property">
  Lie 括积满足:
  <li>双线性性: `[k A + l B, C] = k [A, C] + l[B, C]`, `[A, k B + l C] = k[A, B] + l[A, C]`;</li>
  <li>反对称性 `[A, B] = -[B, A]`;</li>
  <li>二重公式 `[A, B C] = [A, B]C + B[A, C]`;</li>
  <li>Jacobi 恒等式 `sum_"cyc"[[A, B], C] = 0`.</li>
</ol>

<p class="proof">
  4 的证明:
  <span class="formula">
    `sum_"cyc" (A B-B A)C - C(A B-B A)`
    `= sum_"cyc" (A B C - C A B) + sum_"cyc" (C B A - B A C)`
    `= 0 + 0`.
  </span>
</p>

<ol class="remark">
  `RR^3` 中的向量外积也满足类似的性质:
  <li>`bm x xx bm y = -bm y xx bm x`;</li>
  <li>`(k bm x + l bm y) xx bm z = k bm x xx bm z + l bm y xx bm z`;</li>
  <li>`bm x xx (bm y xx bm z) = (bm x * bm z) bm y - (bm x * bm y) bm z`.</li>
  <li>`sum_"cyc" (bm x xx bm y) xx bm z = bb 0`.</li>
</ol>

<ol class="example">
  在 `bbb F^(n xx n)` 中:
  <li>若 `A, B` 是反对称矩阵, 则 `[A, B]` 是反对称矩阵;</li>
  <li>若 `A, B` 是对称矩阵, 则 `[A, B]` 是反对称矩阵;</li>
  <li>若 `A, B` 一个对称, 一个反对称, 则 `[A, B]` 对称.</li>
  总之, 用 1 表示反对称, -1 表示对称, 欲知括积的对称性, 只需将两数相乘.
  性质 1. 是重要的, 它指出 Lie 括积的运算在反对称矩阵中封闭.
</ol>

<p>下面的定理将括积和导子再次联系到一起.</p>

<p class="theorem">
  设 `V` 是定义了乘法的有限维线性空间,
  在 `V` 上定义 `"ad"_A(B) = [A, B]`, 则 `"ad"_A in "Der"V`;
  反之, 对任意 `D in "Der"V`, 存在 `A in V` 使得 `D = "ad"_A`.
</p>

<ol class="proof">
  <li>由括积的性质 3,
    <span class="formula">
      `"ad"_A(B C) = "ad"_A(B) C + B "ad"_A(C)`,
    </span>
    即 `"ad"_A` 是导子.
  </li>
  <li>参见 "derivation of `fr(gl)(V)` must be inner".</li>
</ol>

<ol class="example">
  <b>矩阵运算补遗</b>
  记 `e_(i j)` 是 `i` 行 `j` 列为 1, 其它位置为 0 的 `n xx n` 矩阵.
  <li>令 `A` 是 `n xx n` 矩阵, 则
    <span class="formula">
      `A e_(i j) = "把 "A" 的第 i 列粘贴到零矩阵的第 j 列`,<br>
      `e_(i j) A = "把 "A" 的第 j 行粘贴到零矩阵的第 i 行`.
    </span>
    因此
    <span class="formula">
      `[A, e_(i j)] = A e_(i j) - e_(i j) A`
      `= [
        , , a_(1 i);
        , , vdots;
        -a_(j 1), cdots, a_(i i) - a_(j j), cdots, -a_(j n);
        , , vdots;
        , , a_(n i)
      ]`.
    </span>
  </li>
  <li>`e_(RED i BLUE j) e_(BLUE k RED l) = delta_(BLUE(j k)) e_(RED(i l))`, 因此
    <span class="formula">
      `[e_(RED i BLUE j), e_(BLUE k RED l)] = delta_(BLUE(j k)) e_(RED(i l)) - delta_(RED(l i)) e_(BLUE(k j))`
      `= {
        0, if j != k and i != l;
        e_(RED(i l)), if j = k and i != l;
        -e_(BLUE(k j)), if j != k and i = l;
        e_(RED(i i)) - e_(BLUE(j j)), if j = k and i = l;
      :}`
    </span>
  </li>
  <li>
    记 `E_(i j) = e_(i j) - e_(j i)`, 它是反对称矩阵, `E_(i j) + E_(j i) = 0`, `E_(i i) = 0`.
    利用 `[A, E_(i j)] = [A, e_(i j)] - [A, e_(j i)]`, 我们有
    <span class="formula">
    `[A, E_(i j)] = {:
      , {: ,,,,,,,,,,, i ,,,,,,, j; :};
      {: ;;i;;j;; :},
      [
        ,,,-a_(1 j),,a_(1 i);
        ,,,-a_(2 j),,a_(2 i);
        ,,,vdots,,vdots;
        -a_(j 1),-a_(j 2),...,-a_(j i)-a_(i j),...,-a_(j j)+a_(i i),...,-a_(j n);
        ,,,vdots,,vdots;
        a_(i 1),a_(i 2),...,a_(i i)-a_(j j),...,a_(i j)+a_(j i),...,a_(i n);
        ,,,vdots,,vdots;
        ,,,-a_(n j),,a_(n i)
      ]
      :}`.
    </span>
  </li>
  <li>
    暴力展开得到
    <span class="formula">
      `[E_(i j), E_(k l)]`
      `= delta_(j k) E_(i l) + delta_(i l) E_(j k) + delta_(k i) E_(l j)  + delta_(l j) E_(k i)`.
    </span>
    特别 `i, j, k` 两两不等时,
    <span class="formula">
      `[E_(i j), E_(j k)] = E_(i k)`,
      `quad [E_(i j), E_(k i)] = E_(j k)`.
    </span>
    `i, j, k, l` 两两不等时,
    <span class="formula">
      `[E_(i j), E_(k l)] = 0`.
    </span>
  </li>
  <li>
    记 `tilde E_(i j) = e_(i j) + e_(j i)`, 它是对称矩阵, `tilde E_(i j) = tilde E_(j i)`.
  </li>
</ol>

<h2>Lie 代数</h2>

<h3>Lie 代数的定义</h3>

<ol class="definition">
  `bbb F` 上的线性空间 `V` 上的一个二元运算 `[A, B]`, 如果对任意 `A, B, C in V` 成立:
  <li>双线性性: `[k A + l B, C] = k [A, C] + l[B, C]`, `[A, k B + l C] = k[A, B] + l[A, C]`,
    `k, l in bbb F`;
  </li>
  <li>自相关性: `[A, A] = 0`;</li>
  <li>Jacobi 恒等式: `sum_"cyc"[[A, B], C] = 0`.</li>
  则称 `[A, B]` 是 `V` 上的一个 <b>Lie 括积</b>. `V` 连同其上的 Lie 括积一起构成一个 <b>Lie 代数</b>.
  注意到 `0 = [A+B, A+B]` `= [A, A] + [B, B] + [A, B] + [B, A]`, 因此 2. 又推出:
  <li>反对称性: `[A, B] = -[B, A]`;</li>
  反之, 若 `bbb F` 的特征不等于 2, 则反对称性也可以推出自相关性.
</ol>

<p class="remark">
  今后没有特别说明的情况下, 矩阵构成的线性空间, 如 `CC^(n xx n)` 上面的 Lie 括积统一定义为
  `[A, B] = A B - B A`.
</p>

<p class="definition">
  设 `L` 是一个 Lie 代数, `K` 是 `L` 的线性子空间, 且对括积运算封闭, 则称 `K` 是 `L` 的<b>子代数</b>,
  记为 `K le L`.
</p>

<ol class="example">
  <li>`"End" V` 连同其上的括积运算构成一个 Lie 代数, 记为 `fr(gl)(V)`.</li>
  <li>设 `V` 上有定义乘法, 则 `"Der" V` 是 `fr(gl)(V) = "End" V` 的子代数.
    特别地, Lie 代数 `L` 上的括积运算是一种乘法, 因此 `"Der"L` 有定义.
  </li>
  <li>`V` 上全体迹零的线性变换构成 `fr(gl)(V)` 的子代数, 记为 `fr(sl)(V)`.</li>
</ol>

<p class="proof">
  1, 2 已在前一节中验证过. 下证 3,
  这只需说明 `fr(sl)(V)` 对括积运算封闭:
  设 `A, B` 是迹零的矩阵, 则
  <span class="formula">
    `"tr"[A, B]`
    `= "tr" A B - "tr" A B`
    `= 0`.
  </span>
  `fr(sl)(V)` 的一个基底是
  <span class="formula">
    所有 `e_(i j)`, `quad i != j`,<br>
    以及所有 `e_(i i) - e_(n n)`, `quad n = "dim"V`,
  </span>
  共 `n^2-1` 个矩阵.
</p>

<p class="remark">
  `fr(gl)(V)` 的子代数统称为<b>线性 Lie 代数</b>.
  事实上, 任意有限维 Lie 代数同构于某个线性 Lie 代数.
</p>

<ol class="example">
  线性空间 `V` 上的反对称双线性函数是指一个双线性函数 `f: V xx V to bbb F`, 满足 `f(v, w) = -f(w, v)`.
  对称双线性函数是指 `f(v, w) = f(w, v)`.
  <li>设 `"dim"V = 2l`, 令 `f` 是 `V` 上的反对称双线性函数, 度量矩阵为 `s = [0, I_l; -I_l, 0]`.
    `V` 上一切满足
    <span class="formula">
      `f(x(v), w) = -f(v, x(w))`
    </span>
    的线性变换 `x` 构成 `fr(gl)(V)` 的子代数,
    记为 `fr(sp)(V)`.
  </li>
  <li>将 1. 中 `V` 的维数换成 `2l+1`, `f` 换成对称双线性型,
    度量矩阵为 `[1, 0, 0; 0, 0, I_l; 0, I_l, 0]`,
    条件 `f(x(v), w) = -f(v, x(w))` 不变,
    此时得到奇数维的 Lie 代数 `fr(o)(V)`.
  </li>
  <li>将 1. 中维数换成 `2l`, 度量矩阵换为 `[0, I_l; I_l, 0]`.
    此时得到偶数维的 Lie 代数 `fr(o)(V)`.
  </li>
</ol>

<ol class="proof">
  <li>
    设 `x, y in fr(sp)(V)`, 则
    <span class="formula align">
      `f([x,y](v), w) + f(v, [x,y](w))`<br>
      `= f(x y v - y x v, w) + f(v, x y w - y x w)`<br>
      `= f(x y v, w) - f(y x v, w) + f(v, x y w) - f(v, y x w)`<br>
      `= -f(y v, x w) + f(x v, y w) - f(x v, y w) + f(y v, x w)`<br>
      `= 0`.
    </span>
    因此 `fr(sp)(V)` 对括积运算封闭. 用矩阵的语言,
    `f(x(v), w) = - f(v, x(w))` 可以写为 `x(v)^(sf T) s w = -v^(sf T) s x(w)`, 即 `s x = - x^(sf T) s`.
    设 `m, n, p, q in bbb F^(n xx n)`, 则
    `x = [m, n; p, q] in fr(sp)(2l, bbb F)` 当且仅当 `n, p` 为对称矩阵, 且 `m^(sf T) = -q`
    (最后一个条件推出 `"tr"(x) = 0`).<br>
    `fr(sp)(V)` 的一个基底为
    <span class="formula">
      `m` 与 `q` 的部分: `e_(i j) - e_(l+j, l+i)`, `quad 1 le i le l`, `1 le j le l`,<br>
      `n` 的部分: `e_(i, l+j) + e_(j, l+i)`, `quad 1 le i le l`, `i le j le l`,<br>
      `p` 的部分: `e_(l+i, j) + e_(l+j, i)`, `quad 1 le i le l`, `i le j le l`.
    </span>
    共 `l^2 + 2 * (l(l+1))/2` `= 2l^2 + l` 个矩阵.
  </li>
  <li>
    括积封闭性的证明与 1. 完全类似. 用矩阵的语言, 设 `m, n, p, q in bbb F^(n xx n)`, 则
    `x = [a, b_1, b_2; c_1, m, n; c_2, p, q] in fr(o)(2l+1, bbb F)` 当且仅当 `s x = -x^(sf T) s`,
    即:
    <span class="formula">
      `a = 0`, `c_1 = -b_2^(sf T)`, `c_2 = -b_1^(sf T)`, `m^(sf T) = -q`,
      `n^(sf T) = -n`, `p^(sf T) = -p`.
    </span>
    (以上条件同样蕴含 `"tr"(x) = 0`.
    `fr(o)(V)` (`"dim"V=2l+1`) 的一个基底为
    <span class="formula">
      主对角线: `e_(i i) - e_(l+i,l+i)`, `quad 2 le i le l+1`,<br>
      `b_2` 与 `c_1`: `e_(1, l+i+1) - e_(i+1, 1)`, `quad 1 le i le l`,<br>
      `b_1` 与 `c_2`: `e_(1, i+1) - e_(l+i+1, 1)`, `quad 1 le i le l`,<br>
      `m^(sf T) = -q`: `e_(i+1,j+1) - e_(l+j+1, l+i+1)`, `quad 1 le i != j le l`,<br>
      `n` 反对称: `e_(i+1,l+j+1) - e_(j+1, l+i+1)`, `quad 1 le i lt j le l`,<br>
      `p` 反对称: `e_(i+l+1, j+1) - e_(j+l+1, i+1)`, `quad 1 le j lt i le l`.
    </span>
    共 `3 l + l^2-l + 2*(l(l-1))/2` `= 2l^2 + l` 个矩阵.
  </li>
  <li>证明与 2. 类似, 基底中共 `2l^2 - l` 个矩阵.</li>
</ol>

<ol class="example">
  <li>`fr(t)(n, bbb F)` 是上三角矩阵构成的 Lie 代数.</li>
  <li>`fr(n)(n, bbb F)` 是严格上三角矩阵构成的 Lie 代数.</li>
  <li>`fr(d)(n, bbb F)` 是对角矩阵构成的 Lie 代数.</li>
</ol>

<h3>理想与同态</h3>

<p>本节的内容与群论、环论的相关内容平行.</p>

<p class="definition">
  设 `L` 是 Lie 代数, `I le L`, 若对任意 `x in I`, `y in L` 有 `[x, y] in I`, 则称 `I` 是 `L` 的理想,
  记为 `I normal L`.
</p>

<ol class="example">
  <li>`L normal L`, `0 normal L` 是平凡的理想.</li>
  <li>中心 `Z(L) := { x in L: AA y in L, [x, y] = 0 }` 是 `L` 的理想.</li>
  <li>`I, J` 是 `L` 的理想, 则 `I+J`, `I nn J`,
    <span class="formula">
      `[I,J] := { sum [x_i, y_j]: x_i in I, y_i in J }`
    </span>
    皆是 `L` 的理想.
  </li>
</ol>

<p class="definition">
  如果 Lie 代数 `L` 的括积是非平凡的 (存在 `x, y` 使得 `[x, y] != 0`), 且 `L` 只有平凡的理想,
  则称 `L` 是<b>单</b>的.
</p>

<p class="corollary">
  `L` 是单的, 意味着 `Z(L) = 0`, `[L, L] = L`.
</p>

<p class="proof">
  只需说明 `Z(L) != L`, `[L, L] != 0`.
  这由 `L` 的括积非平凡保证.
</p>

<h2>指数映射与切空间</h2>

<p class="remark">
  指数映射架起了 Lie 群和 Lie 代数之间的桥梁.
  通过指数映射, 我们把一个研究弯曲空间 (Lie 群) 的问题, 简化为研究它的切空间 (Lie 代数).
</p>

<h3>矩阵范数</h3>

<ol class="definition">
  <b>矩阵范数</b> 是一个实函数 `||*||: bbb F^(n xx n) to RR` (`bbb F = RR, CC, bbb H`), 满足
  <li>正定性: `||A|| ge 0`, `||A|| = 0 iff A = 0`;</li>
  <li>次可加性: `||A + B|| le ||A|| + ||B||`;</li>
  <li>齐次性: `||k A|| = |k| ||A||`, `AA k in bbb F`.</li>
  比如, `|A| := sqrt(sum_(i, j) |a_(i j)|^2)` 就是这样一个范数. 今后我们将默认使用这个矩阵范数.
</ol>

<p class="proof">
  只验证次可加性 (Minkowski 不等式):
  <span class="formula align">
    `(sqrt(sum |a_(i j)|^2) + sqrt(sum |b_(i j)|^2))^2`<br>
    `= sum |a_(i j)|^2 + sum |b_(i j)|^2 + 2 sqrt((sum |a_(i j)|^2)(sum |b_(i j)|^2))`<br>
    `ge sum |a_(i j)|^2 + sum |b_(i j)|^2 + 2 sum |a_(i j)| |b_(i j)|` (Cauchy 不等式)<br>
    `= sum |a_(i j) + b_(i j)|^2`.
  </span>
</p>

<p class="corollary">
  <b>矩阵范数的次可乘性</b> `|A B| le |A| |B|`.
  特别 `|A^n| le |A|^n`.
</p>

<p class="proof">
  记 `C = A B`, 使用 Cauchy 不等式,
  <span class="formula">
    `|C|^2 = sum_(i j) |c_(i j)|^2 = sum_(i j) |sum_k a_(i k) b_(k j)|^2`
    `le sum_(i j) (sum_k |a_(i k)|^2)(sum_k |b_(k j)|^2)`
    `= sum_i sum_k |a_(i k)|^2 sum_j sum_k |b_(k j)|^2`
    `= |A| |B|`.
  </span>
</p>

<h3>矩阵指数</h3>

<p class="definition">
  <b>矩阵指数</b>用级数定义为
  <span class="formula">
    `exp(A) = sum_(n ge 0) A^n/n!`,
  </span>
  其中 `A^0 = bb 1` (单位矩阵).
  这个级数是绝对收敛的, 其范数可被常数项级数 `sum_(n ge 0) (|A|^n)/n!` 控制.
</p>

<p class="corollary">
  当 `A B` 可交换时, 有 `exp(A+B) = exp(A) exp(B)`.
</p>

<ol class="corollary">
  <b>Euler 公式</b>
  令 `theta in RR`.
  <li>复数情形: 记 `bb i = [, -1; 1, ]`, 则
    `exp[, -theta; theta, ] = [cos theta, -sin theta; sin theta, cos theta]`,
    即 `"e"^(theta bb i) = bb 1 cos theta + bb i sin theta`,
    这说明矩阵指数的定义与复指数是兼容的;
    反之, 任意单位复数 `z in S^1` 可以写为 `z = "e"^(theta bb i)`.
  </li>
  <li>四元数情形: 令 `u` 是单位纯虚四元数, 即 `u in RR bb i + RR bb j + RR bb k`, 且 `|u| = 1`.
    则 `"e"^(theta u) = cos theta + u sin theta`;
    反之, 任意单位四元数 `q in S^3` 可以写为 `q = "e"^(theta u)`.
  </li>
</ol>

<p class="proof">
  只需注意到 `bb i^2 = -bb 1`, `u^2 = -1`, 又级数绝对收敛, 所以重排后就得到 `cos` 和 `sin` 的级数.<br>
  反之, 令 `z = a + b bb i`, `a^2 + b^2 = 1`, 因此存在 `theta` 使 `a = cos theta`, `b = sin theta`.
  于是 `z = cos theta + bb i sin theta`.<br>
  同理令 `q = a + b bb i + c bb j + d bb k`, `a^2 + b^2 + c^2 + d^2 = 1`, 存在
  `theta` 使 `a = cos theta`, `sqrt(b^2 + c^2 + d^2) = sin theta`,
  于是 `q = cos theta + u sin theta`, 其中 `u = (b bb i + c bb j + d bb k)/sqrt(b^2 + c^2 + d^2)`.
</p>

<ol class="corollary">
  <li>`exp` 将直线 `RR bb i` 上的纯虚数映到单位圆 `SO(2) = S^1`, 且是满射.</li>
  <li>`exp` 将 `RR bb i + RR bb j + RR bb k` 中的纯虚四元数映到单位四元数 `Sp(1) = SU(2) = S^3`, 且是满射.</li>
  注意到 `RR bb i`, `RR bb i + RR bb j + RR bb k` 是平直空间, 而 `S^1, S^3` 等是弯曲空间, 前者可以看作后者在单位元 `bb 1` 处的切线 (切空间).
</ol>

<p>我们给出切空间的定义.</p>

<h3>切空间</h3>

<p class="definition">
  设 `G` 是矩阵 Lie 群, `A(t)` 是 `G` 中经过单位元 `bb 1` 的可微曲线, `A(0) = bb 1`.
  则称 `A'(0)` 是曲线在单位元处的切向量. `G` 在 `bb 1` 处的切空间定义为
  <span class="formula">
    `T_(bb 1)(G) = { A'(0): A(t)" 是 "G" 中经过 "bb 1" 的可微曲线 "}`.
  </span>
</p>

<p class="example">
  <b>Lie 括积的几何意义</b>
  设 `u(s), v(t)` 是矩阵 Lie 群 `G` 在 `bb 1` 处的两条可微曲线, `u(0) = v(0) = bb 1`.
  记
  <span class="formula">
    `w(s, t) = u(s) v(t) u(s)^-1`,
  </span>
  对于每一固定的 `s`, `w(s, t)` 都是一条通过 `bb 1` 的可微曲线. 关于 `t` 在 0 处求导, 就得到它在
  `bb 1` 处的切向量 `x(s)`. 再令 `x(s)` 对 `s` 在 0 处求导, 由于矩阵 Lie 群对极限运算封闭, 可知
  `x'(0)` 也位于切空间 `T_(bb 1)(G)` 中. 这连续两次求导的结果, 正好就是 Lie 括积:
  <span class="formula">
    `{:del/(del s)|_(s=0) {:del/(del t)|_(t=0) w(s, t)`
    `= [u'(0), v'(0)]`.
  </span>
  因此 Lie 括积一定程度上反映了 Lie 群中的共轭运算 `A B A^-1`.
</p>

<p class="proof">
  <span class="formula align">
    `{:del/(del s)|_(s=0) {:del/(del t)|_(t=0) w(s, t)`<br>
    `= {:del/(del s)|_(s=0) u(s) v'(0) u(s)^-1`<br>
    `= {:u'(s) v'(0) u(s)^-1 + u(s) v'(0) (-u'(s) u(s)^-2)|_(s=0)`<br>
    `= u'(0) v'(0) - v'(0) u'(0)`<br>
    `= [u'(0), v'(0)]`.
  </span>
</p>

<script>
var asciimath = {
  define: [
    [/RED/g, 'color(#f42)'],
    [/BLUE/g, 'color(#45a)'],
  ]
}
</script>
<script src="../../js/note.js?type=math"></script>
</body>
</html>
