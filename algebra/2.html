<!DOCTYPE html>
<html lang="zh-cn">

<head>

<title>行列式</title>
<meta charset="utf-8" />

<link rel="stylesheet" type="text/css" href="../css/note.css" />

</head>

<body>

<p class="example">
	计算 `n` 阶行列式
	<span class="formula">`|
		(x" ",y" ",cdots" ",y),
		(y" ",x" ",cdots" ",y),
		(vdots" ",vdots" ", " ",vdots),
		(y" ",y" ",cdots" ",x)
	|`.</span>
</p>

<p class="solution">
	加边法. 设原式等于 `D_n`, 则
	<span class="formula">
	`D_n =`
	`|
		(1" ",-y" ",-y" ",cdots" ",-y),
		(0" ",x" ",y" ",cdots" ",y),
		(0" ",y" ",x" ",cdots" ",y),
		(vdots" ",vdots" ",vdots" ", " ",vdots),
		(0" ",y" ",y" ",cdots" ",x)
	|_(n+1)`
	`=|
		(1" ",-y" ",-y" ",cdots" ",-y),
		(1" ",x-y" ",0" ",cdots" ",0),
		(1" ",0" ",x-y" ",cdots" ",0),
		(vdots" ",vdots" ",vdots" ", " ",vdots),
		(1" ",0" ",0" ",cdots" ",x-y)
	|_(n+1)`.
	</span>
	沿最后一列展开, 再将 `-y` 的余子式沿最后一行展开,
	<span class="formula">
		`D_n = (x-y) D_(n-1) + (-1)^(n+1+1) (-y) (-1)^(n+1) (x-y)^(n-1)`
		`= (x-y) D_(n-1) + y(x-y)^(n-1)`.
	</span>
	两边同除以 `(x-y)^(n-1)`,
	<span class="formula">
		`D_n/(x-y)^(n-1) = D_(n-1)/(x-y)^(n-2) + y`.
	</span>
	于是
	<span class="formula">
		`D_n = (x-y)^(n-1)(D_1/(x-y)^0 + (n-1) y)`
		`= (x-y)^(n-1) (x+(n-1)y)`.
	</span>
</p>

<p class="example">
	计算 `n` 阶行列式
	<span class="formula">
	`|
		(x" ",0" ",cdots" ",0" ",a_0),
		(-1" ",x" ",cdots" ",0" ",a_1),
		(0" ",-1" ",cdots" ",0" ",a_2),
		(vdots" ",vdots" ", " ",vdots" ",vdots),
		(0" ",0" ",cdots" ",-1" ",x+a_(n-1))
	|`.
	</span>
</p>

<p class="solution">
	对 `k = n-1, cdots, 2, 1`, 依次将第 `k+1` 行的 `x` 倍加到第 `k` 行上,
	记 `f(x) = sum_(i=0)^n a_i x^i`, `a_n = 1`,
	原式等于
	<span class="formula">
		`|(0 ,f(x)),
		  (-bm E_(n-1) ,**)
		|`
		`= (-1)^(n-1) |
		  (f(x) ,0),
		  (** ,-bm E_(n-1))
		|`
		`= f(x)`.
	</span>
</p>

<p class="example">
	<b>Vandermonde 行列式</b>
	对正整数 `n ge 2`,
	<span class="formula">`|
		(1," "x_1," "cdots," "x_1^(n-1)),
		(1," "x_2," "cdots," "x_2^(n-1)),
		(vdots," "vdots," "," "vdots),
		(1," "x_n," "cdots," "x_n^(n-1))
	| = prod_(1 le i lt j le n) (x_j - x_i)`.</span>
</p>

<p class="proof">
	对 `n` 进行归纳证明. `n = 2` 时原式等于 `x_2 - x_1`, 结论成立.
	设结论对 `n-1` 成立, 依次将原式第 `i` 列的 `-x_1` 倍加到第 `i+1` 列,
	`i = n-1, n-2, cdots, 1`, 得到
	<span class="formula">`|
		(1," "0," "cdots," "0),
		(1," "x_2-x_1," "cdots," "x_2^(n-2)(x_2-x_1)),
		(vdots," "vdots," "," "vdots),
		(1," "x_n-x_1," "cdots," "x_n^(n-2)(x_n-x_1))
	|`.</span>
	按第一行展开后, 提出每一行的公因式, 得
	<span class="formula">`prod_(j=2)^n (x_j-x_1) |
		(1," "cdots," "x_2^(n-2)),
		(vdots," "," "vdots),
		(1," "cdots," "x_n^(n-2))
	|`.</span>
	由归纳假设, 上式等于
	<span class="formula">
		`prod_(1 le i lt j le n) (x_j-x_i)`.
	</span>
</p>

<p class="corollary">
	Vandermonde 行列式不等于 0 当且仅当 `x_1, x_2, cdots, x_n` 两两不相等.
</p>

<p class="example">
	求行列式
	<span class="formula">`|
		(1, ((m_1),(1)), cdots, ((m_1),(n-1))),
		(1, ((m_2),(1)), cdots, ((m_2),(n-1))),
		(vdots, vdots, , vdots),
		(1, ((m_n),(1)), cdots, ((m_n),(n-1)))
	|`.</span>
</p>

<p class="solution">
	因为 `((m),(k))` 可以看成是关于 `m` 的 `k` 次多项式,
	因此依次将原式的前 `i` 列的某个线性组合加到第 `i+1` 列, 就可以消去
	第 `i+1` 列中的低次项, 使其只剩 `i` 次项, `i = 2, 3, cdots, n-1`.
	从而得到
	<span class="formula">`|
		(1," "m_1/(1!)," "cdots," "m_1^(n-1)/((n-1)!)),
		(1," "m_2/(1!)," "cdots," "m_2^(n-1)/((n-1)!)),
		(vdots," "vdots," "," "vdots),
		(1," "m_n/(1!)," "cdots," "m_n^(n-1)/((n-1)!))
	|`.</span>
	利用 Vandermonde 行列式, 上式等于
	<span class="formula">
		`prod_(i=1)^(n-1) (i!)^-1 prod_(1 le i lt j le n) (m_j-m_i)`.
	</span>
</p>

<p class="example">
	设 `bm A in bbb P^(m xx n)`, `bm B in bbb P^(n xx m)`, 证明:
	<span class="formula">
		` |bm E_m - bm (AB)|
		= |(bm E_n, bm B),(bm A, bm E_m)|
		= |(bm E_m, bm A),(bm B, bm E_n)|
		= |bm E_n - bm (BA)|`.
	</span>
	当 `m != n`, 此公式可以用于降阶.
</p>

<ol class="proof">
	<li>先证第一个等号. 由行列式的相关性质和矩阵的分块乘法,
		<span class="formula">
			` |bm E_m - bm (AB)|
			= |(bm E_n, bm O), (bm O, bm E_m - bm (AB))|`
			`= |(bm E_n, bm O), (-bm A, bm E_m)|
			  |(bm E_n, bm B), (bm A, bm E_m)|
			  |(bm E_n, -bm B), (bm O, bm E_m)|
			= |(bm E_n, bm B), (bm A, bm E_m)|`.
		</span>
		类似可以证明第三个等号.
	</li>
	<li>再证第二个等号.
		先交换左边行列式的前 `n` 列与后 `m` 列, 得到
		`|(bm B, bm E_n),(bm E_m, bm A)|`.
		这可以通过把后 `m` 列逐列前移 `n` 个位置得到, 因此需要交换 `mn`
		次. 再交换它的前 `n` 行与后 `m` 行来得到右边的行列式; 同样需要
		`mn` 次交换. 由于交换行/列的次数是偶数, 行列式的值不变.
	</li>
</ol>

<h3>Laplace 定理</h3>

<a href="https://www.jianshu.com/p/527a17b9e674">原文来自简书</a>

<p class="definition">
	<b>子式, 余子式和代数余子式</b>
	令 `D` 为一个 `n` 阶行列式, `1 le k le n`. 在 `D` 上任意选定 `k` 行
	`k` 列, 位于这些行和列的交点上的 `k^2` 个元素按原来的 "上下左右"
	的次序组成一个 `k` 阶行列式 `M`, 称为 `D` 的一个 <b>`k` 阶子式</b>.
	若 `k lt n`, 在 `D` 中划去这 `k` 行 `k` 列后,
	余下的元素按原来的次序组成一个 `n-k` 阶行列式 `N`,
	称为 `M` 在 `D` 中的<b>余子式</b>. 由定义, `M` 也是 `N` 的余子式,
	因此又称 `M, N` 为一对互余的子式.
	如果 `M` 的各行, 列在原行列式 `D` 中的指标为 `i_1, i_2, cdots, i_k`
	和 `j_1, j_2, cdots, j_k`, 则称
	<span class="formula">
		`(-1)^(sum_(t=1)^k (i_t + j_t)) N`
	</span>
	为 `M` 在 `D` 中的<b>代数余子式</b>.
</p>

<p class="lemma">
	行列式 `D` 的任一子式 `M` 与它的代数余子式 `A` 的乘积中的每一项都是
	`D` 的展开式中的一项, 且符号一致.
</p>

<ol class="proof">
	<li>假设 `M` 是 `D_(n xx n) = |a_(ij)|` 的左上方的 `k` 阶子式, 即 `M`
		由 `D` 的前 `k` 行和前 `k` 列交叉处的元素组成, 则 `M`
		的每一项可以写作
		<span class="formula">
			`(-1)^(tau(i_1 i_2 cdots i_k))`
			`a_(1 i_1) a_(2 i_2) cdots a_(a i_k)`,
		</span>
		其中 `i_1 i_2 cdots i_k` 是 `1, 2, cdots, k` 的一个排列.
		而 `M` 的余子式 `N` 的每一项可以写作
		<span class="formula">
			`(-1)^(tau(j_1 j_2 cdots j_(n-k)))`
			`a_(k+1, j_1) a_(k+2, j_2) cdots a_(n, j_(n-k))`,
		</span>
		其中 `j_1 j_2 cdots j_(n-k)` 是 `k+1, k+2, cdots, n` 的一个排列.
		两个通项相乘得
		<span class="formula">
			`(-1)^(tau(i_1 i_2 cdots i_k j_1 j_2 cdots j_(n-k))`
			`a_(1 i_1) a_(2 i_2) cdots a_(k i_k)`
			`a_(k+1, j_1) a_(k+2, j_2) cdots a_(n, j_(n-k))`.
		</span>
		上式再乘以代数余子式的符号
		<span class="formula">
			`(-1)^(sum_(t=1)^k (t+t)) = 1`
		</span>
		即为 `D` 的展开式中的一项, 且符号一致.
	</li>
	<li>下证一般情形, 设 `M` 位于 `D` 的第 `i_1, i_2, cdots, i_k` 行,
		第 `j_1, j_2, cdots j_k` 列, 其中
		`i_1 lt i_2 lt cdots lt i_k`, `j_1 lt j_2 lt cdots lt j_k`.
		作行列的对换, 将 `M` 移到 `D` 的左上角:
		先把第 `i_1` 行依次与第 `i_1-1, i_1-2, cdots, 2, 1` 行对换,
		经过 `i_1-1` 次对换而将它换到第 1 行.
		再将第 `i_2` 行依次与第 `i_2-1, i_2-2, cdots, 2` 行对换,
		经过 `i_2-2` 次对换而将它换到第 2 行...
		如此下去, 经过 `sum_(t=1)^k (i_t-t)` 次对换, 把第 `i_1, i_2,
		cdots, i_k` 行换到第 `1, 2, cdots, k` 行.
		类似地经过 `sum_(t=1)^k (j_t-t)` 次列对换, 可将第 `j_1, j_2,
		cdots, j_k` 列换到第 `1, 2, cdots, k` 列.
		从而变换前后, 行列式 `D` 的值相差一个符号
		<span class="formula">
			`(-1)^(sum_(t=1)^k (i_t+j_t))`.
		</span>
		恰为 `M` 的代数余子式前的符号因子, 因此 `M`
		与它的代数余子式乘积中的每一项都是 `D` 的展开式中的一项,
		且符号一致.
	</li>
</ol>

<p class="theorem">
	<b>Laplace 定理</b>
	`n` 阶行列式的值等于它的任意 `k` (`1 le k le n-1`) 行 (列)
	中所含有的全体 `k` 阶子式与相应代数余子式的乘积的和.
</p>

<p class="proof">
	由行列式行和列的对称性, 只证行的情形.
	设 `n` 阶行列式 `D` 中取定 `k` 行后得到的子式为 `M_i`,
	相应的代数余子式为 `A_i`, `i = 1, 2, cdots, s`. 下证
	<span class="formula">
		`D = sum_(i=1)^s M_i A_i`.
	</span>
	显然, `M_i A_i` 中每一项都是 `D` 的展开式中的一项且符号一致,
	且 `i!=j` 时, `M_i A_i` 与 `M_j A_j` 无公共项.
	因此要证结论成立, 只需指出等式左右含展开式的项数相等.
	由于 `n` 阶行列式的展开式有 `n!` 项, 故等式左端有 `n!` 项.
	而由子式的取法知 `s = ((n),(k))`, 故等式右端的项数为
	<span class="formula">
		`((n),(k)) k! (n-k)! = n!`.
	</span>
	证毕.
</p>

</body>

<script src="../js/note.js?type=math"></script>

</html>
