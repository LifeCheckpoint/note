<!DOCTYPE html>
<html lang="zh-cn">

<head>

<title>整除</title>
<meta charset="utf-8" />

<link rel="stylesheet" type="text/css" href="../css/note.css" />

</head>

<body>

<h2>整数</h2>

<p class="definition">
	<b>自然数</b>又叫<b>正整数</b>, 即熟知的
	<span class="formula">
		`1, 2, 3, cdots, n, cdots`.
	</span>
	用 `NN` 表示全体自然数的集合.
	<br/>
	<b>整数</b>是指正整数, 负整数及零, 即
	<span class="formula">
		`0, +-1, +-2, +-3, cdots, +-n, cdots`.
	</span>
	用 `ZZ` 表示全体整数的集合.
</p>

<h3>整数的运算</h3>

<ol class="enum">
	整数集合 `ZZ` 关于其上的加法 "`+`" 与乘法 "`*`" 成一<b>整环</b>, 即
	<br/>
	<li>
	关于加法与乘法成一环.
	<ol>
		关于加法成一 Abel 群.
		<li>封闭性. `(AA a, b in ZZ)` `a + b in ZZ`;</li>
		<li>结合律. `(AA a, b, c in ZZ)` `(a+b)+c = a+(b+c)`;</li>
		<li>存在零元. `(EE 0 in ZZ)`, `(AA a in ZZ)` `a + 0 = a`;</li>
		<li>存在负元. `(AA a in ZZ)`, `(EE -a in ZZ)` `a + (-a) = 0`;</li>
		<li>交换律. `(AA a, b in ZZ)`, `a+b = b+a`;</li>
		关于乘法成一半群.
		<li>封闭性. `(AA a, b in ZZ)` `a * b in ZZ`;</li>
		<li>结合律. `(AA a, b, c in ZZ)` `(a*b)*c = a*(b*c)`;</li>
		满足加法对乘法的分配律: <!-- 写反了吗 -->
		<li>`(AA a, b, c in ZZ)` `a * (b + c) = a*b + a*c`.</li>
	</ol>
	</li>
	<li>无零因子. `(AA a, b in ZZ)` `a * b = 0 rArr a = 0 or b = 0`;</li>
	<li>乘法交换律. `(AA a, b in ZZ)` `a*b = b*a`;</li>
	<li>有乘法幺元. `(EE 1 in ZZ)` `(AA a in ZZ)` `a * 1 = a`;
		但是, 不一定有乘法逆元.
	</li>
	因此, 也称 `ZZ` 为<b>整数环</b>.
	简单起见, 字母间的乘法 `a*b` 简记为 `ab`,
	减法 `a + (-b)` 简记为 `a-b`.
</ol>

<p>从整数乘法的无零因子可以推出它满足的消去律:
	<span class="formula">
		`(AA a in ZZ\\{0}, b, c in ZZ)` `a*b = a*c rArr b = c`.
	</span>
</p>

<h3>整数的序</h3>

<ol class="enum">整数环 `ZZ` 上有一<b>全序</b> `le`, 即满足
	<br/>
	<li>`le` 为一偏序.
	<ol>
		<li>自反性. `(AA a in ZZ)` `a le a`;</li>
		<li>反对称性. `(AA a, b in ZZ)` `a le b and b le a rArr a =
			b`;
		</li>
		<li>传递性. `(AA a, b, c in ZZ)` `a le b and b le c rArr a le
			c`.
		</li>
	</ol>
	据此可以定义 `ge, lt, gt` 如下: 对 `a, b in ZZ`,
	<span class="formula">
		`a ge b iff b le a`;<br/>
		`a lt b iff a le b and a != b`;<br/>
		`a gt b iff a ge b and a != b`.
	</span>
	</li>

	<li>任意两个整数之间可以比较大小.
		`AA a, b in ZZ`, `a=b, a lt b, a gt b` 有且仅有一个成立.
	</li>
</ol>

<ol>全序 `le` 与 `ZZ` 上的运算<b>相容</b>, 即 
	<li>`(AA a, b, c in ZZ)` `a + c le b + c iff a le b`;</li>
	<li>`(AA a, b in ZZ, c in NN)` `a c le b c iff a le b`;</li>
	<li>`(AA a, b in ZZ)` `a le b iff -a ge -b`;</li>
</ol>

<ol>一些额外的性质
	<li>`(AA a, b, c in NN)` `c = ab rArr a le c`, 等号成立当且仅当 `b =
		1`.
	</li>
	<li>`(AA a, b in NN)` `a lt b iff a + 1 le b iff a le b-1`.</li>
</ol>

<h3>整数的绝对值</h3>

<p class="definition">
	对任意 `a in ZZ`, 定义它的<b>绝对值</b>为
	<span class="formula">
		`|a| = {
			(a, if a in NN),
			(0, if a = 0),
			(-a, if -a in NN)
		:}`
	</span>
</p>

<ol>借助绝对值容易建立等价关系 `~: a ~ b iff |a| = |b|`, 满足
	<li>自反性. `(AA a in ZZ)` `a ~ a`;</li>
	<li>对称性. `a ~ b rArr b ~ a`;</li>
	<li>传递性. `a ~ b and b ~ c rArr a ~ c`.</li>
</ol>

<p>	绝对值具有性质
	<span class="formula">
		`|ab| = |a| * |b|`, `AA a, b in ZZ`;<br/>
		`|a + b| le |a| + |b|`. `AA a, b in ZZ`.
	</span>
</p>

<h3>归纳原理与数学归纳法</h3>

<ol><b>归纳原理</b>
	设 `S sube NN` 满足条件
	<li>`1 in S`;</li>
	<li>`n in S rArr n+1 in S`, `AA n ge 1`,</li>
	则 `S = NN`.
</ol>

<p>	归纳原理是自然数最重要, 最本质的性质.
</p>

<ol class="theorem">
	<b>(第一) 数学归纳法</b>
	设 `P(n)` 是关于自然数 `n` 的一种性质或命题. 如果
	<li>`P(1)` 成立;</li>
	<li>由 `P(n)` 成立可以推出 `P(n+1)` 成立, `AA n ge 1`,</li>
	那么 `P(n)` 对任意的自然数 `n` 成立.
</ol>

<p class="proof">
	对集合 `S = {n in NN: P(n)}` 应用归纳原理即得.
</p>

<p class="theorem">
	<b>最小自然数原理</b>
	设 `O/ != T sube NN`, 则 `T` 中存在<b>最小</b>自然数, 即
	<span class="formula">
		`(EE t_0 in T)` `(AA t in T)` `t_0 le t`.
	</span>
</p>

<p class="proof">
	令 `S = {s in NN: AA t in T, s le t}` 是 `T` 的全体<b>下界</b>.
	易知 `1 in S`, 故 `S` 非空.
	<br/>
	由于 `T` 非空, 取 `t_1 in T`,
	则 `t_1 + 1 gt t_1`, 所以 `t_1 + 1 !in S`, 这说明 `S != NN`.
	由归纳原理, 存在 `s_0 in S`, `s_0 + 1 !in S`.
	<br/>
	下证 `s_0 in T`.  若不然, 则对任意 `t in T`, `s_0 lt t`,
	即 `s_0 + 1 le t`, 故 `s_0 + 1 in S`, 矛盾.
	<br/>
	`s_0` 即为 `T` 中的最小自然数.
</p>

<p class="theorem">
	<b>最大自然数原理</b>
	设 `O/ != M sube NN` 且有<b>上界</b>, 即
	<span class="formula">
		`(EE a in NN)` `(AA m in M)` `m le a`,
	</span>
	则 `M` 中存在<b>最大</b>自然数, 即
	<span class="formula">
		`(EE m_0 in M)` `(AA m in M)` `m le m_0`.
	</span>
</p>

<p class="proof">
	令 `T` 是 `M` 的全体上界, 由条件知 `T` 非空.
	<br/>
	由最小自然数原理知, 集合 `T` 中有最小自然数 `t_0`, 下证 `t_0 in M`,
	若不然, 则对任意 `m in M`, `m lt t_0`,
	即 `m le t_0 - 1`, 从而 `t_0 - 1 in T`, 与 `t_0` 是 `M`
	的最小上界矛盾.
	<br/>
	`t_0` 即为 `M` 中的最大自然数.
</p>

<p class="remark">
	从证明过程可以看出,
	整数集合中的最小自然数与最大自然数分别等于其下确界与上确界.
</p>

<ol class="theorem">
	<b>第二数学归纳法</b>
	设 `P(n)` 是关于自然数 `n` 的一种性质或命题. 如果
	<li>`P(1)` 成立;</li>
	<li>由 `P(m)` 对任意自然数 `m lt n` 成立可以推出 `P(n)` 成立, `n gt 1`,</li>
	那么 `P(n)` 对任意的自然数 `n` 成立.
</ol>

<p class="proof">
	反设集合 `T = {t in NN: not P(t)}` 非空, 则它有最小元 `t_0`,
	由 `P(1)` 成立知 `t_0 gt 1`,
	于是对任意自然数 `m lt t_0`, `P(m)` 成立,
	由2, 这蕴含 `P(t_0)` 成立, 矛盾.
</p>

<p>	本节的最后介绍初等数论中另一个常用的工具. 这可以由反证法得到.</p>

<p class="theorem">
	<b>鸽巢原理</b>
	设 `n in NN`. 集合 `X` 有 `n+1` 个元素, 集合 `Y` 有 `n` 个元素,
	则 `X` 到 `Y` 的映射一定不是单射. 换言之, 将 `n+1` 个物体放入 `n`
	个盒子, 一定有一个盒子放入了两个或两个以上的物体.
</p>

<h2>整除, 因子, 素数</h2>

<h3>整除与因子</h3>

<p class="definition">
	设 `a in ZZ\\{0}, b in ZZ`. 称 <b>`a` 整除 `b`</b>, 如果
	<span class="formula">
		`(EE q in ZZ)` `b = aq`.
	</span>
	我们也说 <b>`b` 被 `a` 整除</b>, <b>`a` 是 `b` 的因子 (因数, 约数,
	除数)</b>, <b>`b` 是 `a` 的倍数</b>等.
	`a` 整除 `b` 记为 `a | b` 或 `b vdots a`. `a` 不能整除 `b` 记为
	`a !| b`.
	<br/>
	`a` 的全体倍数的集合记为
	<span class="formula">
		`a ZZ = {aq: q in ZZ}`.
	</span>
	对任意 `a in ZZ\\{0}`, 显然有 `0 in a ZZ`.
</p>

<p class="definition">
	设 `n in ZZ`, 称 `n` 为<b>偶数</b>, 如果 `2 | n`,
	否则称它为<b>奇数</b>.
</p>

<p class="remark">
	下文中总假定 `a | b` 这一表达式有意义, 即 `a != 0`.
</p>

<ol class="theorem" id="the-divisor">
	对任意 `a, b, c in ZZ`,
	<li>`a | b` `iff |a| | |b|`;</li>
	<li>`a | b` `and b | c` `rArr a | c`;</li>
	<li>`a | b` `and b | a` `rArr |a| = |b|`;</li>
	因此, 在绝对值相等的意义下, 整除关系 "`|`" 构成 `ZZ` 上的偏序.
	<li>`(AA m in ZZ\\{0})` `a | b` `iff m a | m b`;</li>
	<li>`(AA b in ZZ\\{0})` `a | b` `rArr |a| le |b|`.</li>
	<li>`a | b` `and a | c` `iff (AA x, y in ZZ)` `a | b x + c y`,
		即 `a` 整除 `b, c` 的任意<b>线性组合</b>;
		这条性质可以推广到任意有限个整数.
	</li>
</ol>

<ol class="proof">
	<li>由 `b = +-aq iff |b| = |a| |q|` 知 1 成立;</li>
	<li>由 `b = aq_1`, `c = bq_2` 得 `c = a q_1 q_2`, 所以 2 成立;</li>
	<li>由 `b = aq_1`, `a = bq_2` 得 `a = a q_1 q_2`, 而 `a != 0`, 故 `q_1
		q_2 = 1`. 由于 1 的因子只有 `+-1`, 所以 `q_1 = +-1`, 即 `b = +-a`;
	</li>
	<li>由乘法消去律知 `b = aq iff mb = maq`;</li>
	<li>`b = aq rArr |b| = |a| |q|`, 由 `b != 0` 知 `|b|, |a|, |q| in NN`,
		由整数序关系的额外性质 1, `|a| le |b|`;
	</li>
	<li>`lArr` 显然. `rArr`: 由 `b = aq_1`, `c = aq_2` 得
		`bx+cy = a(q_1 x + q_2 y)`.
	</li>
</ol>

<p class="example">
	设 `a, b in ZZ\\{0}`, `x, y in ZZ` 满足 `ax + by = 1`.
	证明: `a | n`, `b | n` 的充要条件是 `ab | n`.
</p>

<p class="proof">
	充分性显然. 必要性: 由 `n = a s = b t` 得
	<span class="formula">
		`s = (ax + by)s = btx + bys`,
	</span>
	故 `b | s`, 进而 `ab | as = n`.
</p>

<p class="example">
	设 `f(x)` 为整系数多项式, 若 `d | a - b`, 则 `d | f(a) - f(b)`.
</p>

<p class="corollary">
	全体整数都是零的因子;
	由<a class="ref" href="#the-divisor"></a>的 5,
	非零整数的因子只有有限个.

	如 12 的全体因子是 `{+-1, +-2, +-3, +-4, +-6, +-12}`;
	7 的全体因子是 `{+-1, +-7}`.
</p>

<p class="corollary" id="cor-dividend-eq-0">
	由<a class="ref" href="#the-divisor"></a>的 5 还可以得到,
	如果 `a, b in ZZ`, `a | b` 且 `b lt |a|`, 那么 `b = 0`.
</p>

<p class="theorem" id="the-divisor-in-pairs">
	设 `b in ZZ\\{0}`, 它的全体因子是 `{d_1, d_2, cdots, d_k}`,
	则 `{b//d_1, b//d_2, cdots, b//d_k}` 也是它的全体因子;
	设 `b' in NN`, 它的全体正因子是 `{d_1', d_2', cdots, d_k'}`,
	则 `{(b')//(d_1'), (b')//(d_2'), cdots, (b')//(d_k')}`
	也是它的全体正因子.
</p>

<p class="proof">
	只证第一个结论, 第二个结论的证明类似.
	设 `d_i | b`, 则 `b = d_i (b // d_i)`, 且 `b//d_i in ZZ\\{0}`.
	所以 `b//d_i | b`. 另一方面, `d_i != d_j` 时, 有 `b//d_i != b//d_j`.
	所以 `b//d_1, b//d_2, cdots, b//d_k` 是 `b` 的 `k` 个不同的因子,
	即为 `b` 的全体因子.
</p>

<h3>素数</h3>

<p class="definition">
	设 `b in ZZ`. 显然 `+-1, +-b` 是 `b` 的因子, 称为 `b`
	的<b>平凡因子</b>. `b` 的其他因子称为<b>非平凡因子</b>或<b>真因子</b>.

	设 `n in NN\\{1}`, 如果 `n` 只有平凡因子, 则称它是<b>素数 (prime
	number)</b>; 否则称它是<b>合数 (composite number)</b>.
</p>

<p class="example">
	100 以内的素数有 25 个:
	<span class="formula">
		2,  3,  5,  7,  11, 13, 17, 19, 23, 29,
		31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
		73, 79, 83, 89, 97.
	</span>
</p>

<ol class="corollary" id="cor-prime-iff">
	<li>素数 `p` 的大于 1 的因子只有 `p` 自身;</li>
	<li>设 `n in NN\\{1}`. 则 `n` 是合数的充要条件是存在整数
		`1 lt n_1, n_2 lt a`, 使得 `n = n_1 n_2`.
	</li>
</ol>

<p class="theorem" id="the-composite-has-prime-divisor">
	合数必有素因子.
</p>

<p class="proof">
	设 `T` 是合数 `n` 的全体非平凡正因子的集合, 由定义 `T != O/`.
	由最小自然数原理, `T` 中有最小元素 `p`.
	若 `p` 是合数, 则 `p` 有非平凡因子 `d`, `2 le d lt p`. 显然 `d in T`,
	这与 `p` 是 `T` 的最小元素矛盾. 故 `p` 是素数.
</p>

<p class="theorem">
	<b>算术基本定理 (素因子分解定理)</b>
	任意整数 `n in NN\\{1}` 可以表为素因子的乘积
	<span class="formula">
		`n = prod_(i=1)^s p_i`,
	</span>
	其中 `p_i` 是素数, `i = 1, 2, cdots, s`,
	且这一乘积在不计素因子次序的情况下唯一.
	如果将相同的素因子合并, 上式可写为<b>标准分解式</b>
	<span class="formula">
		`n = prod_(i=1)^l p_i^(m_i)`,
	</span>
	其中 `m_i in NN`, `i = 1, 2, cdots, l` 是<b>重数</b>.
	换言之, 任意整数 `n in NN\\{1}` 都唯一对应着一个素数的<b>多重集合</b>
	<span class="formula">
		`{p_1: m_1, p_2: m_2, cdots, p_l: m_l}`.
	</span>
</p>

<p class="remark">
	算术基本定理是本章的主要结果, 也是数学中最重要和最基本的定理之一.
	在此后我们还要对它做进一步讨论. 这里先证明存在性, 唯一性留待以后证明.
</p>

<p class="proof">
	先证存在性.
	当 `n = 2` 时, 2 是素数, 所以结论成立.
	假设结论对任意整数 `2 le a lt n` 都成立, 考虑 `n` 的情形.
	若 `n` 是素数, 结论已经成立; 若 `n` 是合数, 则由<a class="ref"
	href="#cor-prime-iff"></a>, 存在整数
	`2 le n_1, n_2 lt n` 使得 `n = n_1 n_2`.
	由归纳假设, `n_1, n_2` 有素因子分解
	<span class="formula">
		`n_1 = prod_(i=1)^s p_i`, `quad n_2 = prod_(i=1)^t q_i`.
	</span>
	于是 `n = p_1 p_2 cdots p_s q_1 q_2 cdots q_t`.
	由第二数学归纳法, 存在性得证.
</p>

<ol class="corollary">
	设 `n in NN\\{1}`,
	<li>若 `n` 是合数, 则 `n` 有不超过 `sqrt n` 的素因子;</li>
	<li>若 `n` 可以表为 `s` 个素因子的乘积, 则 `n` 有不超过 `n^(1/s)`
		的素因子.
	</li>
</ol>

<p class="algorithm">
	<b>Eratoschenes 筛法</b>
	求不超过 `N` 的全体素数.
	<!-- 未完待续 -->
</p>

<p class="theorem" id="the-primes-inf">
	素数有无穷多个.
</p>

<p class="proof">
	反设素数有限, 为 `p_1, p_2, cdots, p_n`.
	考虑 `a = prod_(i=1)^n p_i + 1`, 显然 `a` 大于任意一个素数,
	因此是合数.
	由<a class="ref" href="#the-composite-has-prime-divisor"></a>,
	`a` 有素因子 `p | a`. 设 `p = p_j`, 则
	<span class="formula">
		`p = p_j | a - prod_(i=1)^n p_i = 1`,
	</span>
	与 `p ge 2` 矛盾.
</p>

<ol class="theorem">
	用 `pi(n)` 表示不超过 `n` 的素数的个数. 用 `p_n` 表示第 `n` 个素数
	(`p_1 = 2`). 则
	<li>`p_n le 2^(2^(n-1))`, `n = 1, 2, cdots`;</li>
	<li>`pi(n) gt log_2 log_2 n`, `n = 2, 3, cdots`.</li>
</ol>

<ol class="proof">
	<li>由<a class="ref" href="#the-primes-inf"></a>的证明知
		<span class="formula">
			`p_(n+1) le prod_(i=1)^n p_i + 1`, `n = 1, 2, cdots`.
		</span>
		`n = 1` 时, 结论 1 显然成立.
		现在设结论 1 对任意整数 `1 le i le n` 成立, 考虑 `n+1` 的情形.
		由上式及归纳假设得
		<span class="formula">
			`  p_(n+1)
			le prod_(i=1)^n 2^(2^(i-1)) + 1
			=  2^(2^n-1) + 1
			lt 2^(2^n-1) + 2^(2^n-1)
			=  2^(2^n)`.
		</span>
		由第二数学归纳法知结论 1 成立.
	</li>
	<li>对 `n ge 2`, 由最大自然数原理, 必有唯一的正整数 `k`, 使得
		<span class="formula">
			`2^(2^(k-1)) le n lt 2^(2^k)`,
		</span>
		利用 `pi(n)` 的单调性,
		<span class="formula">
			`pi(n) ge pi(2^(2^(k-1))) ge k gt log_2 log_2 n`.
		</span>
	</li>
</ol>

<p class="remark">
	今后我们会介绍 `p_n` 与 `pi(n)` 的更好的估计.
</p>

<h2>带余除法</h2>

<p class="theorem" id="the-division-algorithm">
	设 `a in ZZ\\{0}`, `b in ZZ`, 则存在唯一的整数 `q` 与 `r`, 满足
	<span class="formula">
		`b = aq + r`, `0 le r lt |a|`.
		<span class="label" id="for-division-algorithm"></span>
	</span>
	此外, `a | b` 当且仅当 `a | r`,
	由<a class="ref" href="#cor-dividend-eq-0"></a>,
	这当且仅当 `r = 0`.
</p>

<ol class="proof">
	<li>唯一性. 若还有整数 `q', r'` 满足
		<a class="ref" href="#for-division-algorithm"></a>,
		不妨设 `r' ge r`, 于是
		<span class="formula">
			`r' - r = a (q - q')`,
			`0 le r' - r lt |a|`.
		</span>
		由<a class="ref" href="#cor-dividend-eq-0"></a>得 `r' - r = 0`.
		再由 `a != 0` 得 `q - q' = 0`.
	</li>
	<li>存在性. 当 `a | b` 时, 可取 `q = b//a`, `r = 0`.
		当 `a !| b` 时, 考虑集合
		<span class="formula">
			`T = {b-ak: k in ZZ}`.
		</span>
		容易看出 `T` 中含有正整数 (如取 `k = -2|b|a`),
		所以由最小自然数原理, `T` 中存在最小正整数, 设为
		`t_0 = b - a k_0`.
		<br/>
		下证 `t_0 lt |a|`. 因为 `a !| b`, 所以 `t_0 != |a|`.
		若 `t_0 gt |a|`, 则 `t_1 = t_0 - |a| gt 0 in T`, 与 `t_0` 是
		`T` 的最小元素矛盾. 所以 `t_0 lt |a|`. 这时取 `q = k_0`,
		`r = t_0` 即满足要求.
	</li>
</ol>

<p class="theorem" id="the-division-algorithm-2">
	设 `a in ZZ\\{0}, b, d in ZZ`, 则存在唯一的整数 `q, r` 满足
	<span class="formula">
		`b = a q + r`,
		`d le r lt |a| + d`.
	</span>
	此外, `a | b` 当且仅当 `a | r`.
</p>

<p class="proof">
	对 `a` 和 `b-d` 应用<a class="ref" href="#the-division-algorithm"></a>
	即得.
</p>

<ul class="definition">
	一般地, 称<a class="ref" href="#the-division-algorithm-2"></a>中由 `a,
	b` 得到 `q, r` 的算法为 `a` 除 `b` (或 `b` 模 `a`, 或 `b` 被 `a` 除,
	或 `b` 除以 `a`) 的<b>带余除法</b>.
	`a` 称为<b>除数</b>, `b` 为<b>被除数</b>, `q` 为 `a` 除 `b`
	的<b>商</b>, `r` 为 `a` 除 `b` 的<b>余数</b>.
	取不同的 `d` 值, 就得到不同的带余除法:
	<li>取 `d = 0` 时, `0 le r lt |a|`, 称为<b>最小非负余数</b>;
		没有特别指明时, 余数都指最小非负余数;
	</li>
	<li>取 `d = 1` 时, `1 le r le |a|`, 称为<b>最小正余数</b>.</li>
	<li>取 `d = -|__ |a|/2 __|` 时, `-|a|/2 le r lt |a|/2`,
		称为<b>绝对最小余数</b>;
	</li>
	<li>取 `d = 1 - |__ |a|/2 __|` 时, `-|a|/2 lt r le |a|/2`,
		也称为绝对最小余数; 当 `a` 为奇数时, 两个绝对最小余数相等.
	</li>
</ul>

<p class="example">
	设 `n in NN\\{1}`, `0 le r lt n`. 记全体模 `n` 余数等于 `r` 的整数为
	<span class="formula">
		`S_(n,r) = {kn + r: k in ZZ}`.
	</span>
	我们有
	<span class="formula">
		`uuu_(r=0)^(n-1) S_(n,r) = ZZ`; `quad`
		`S_(n,r_1) nn S_(n,r_2) = O/`, `r_1 != r_2`.
	</span>
	即全体整数按模 `n` 的余数分为 `n` 个类, 称为<b>模 `n` 的同余类</b>.
	在每一同余类中的数模 `n` 后有相同余数, 称它们<b>模 `n` 同余</b>,
	记为 `a -= b (mod n)`. 显然
	<span class="formula">
		`a -= b (mod n) iff n | a - b`.
	</span>
</p>

<p class="example">
	设 `a in NN\\{1}`, `n in NN`. 则 `n` 可以唯一地表为
	<span class="formula">
		`n = sum_(i=0)^m r_i a^i`, `quad`
		`m ge 0`, `0 le r_i lt a`, `0 le i le m`.
	</span>
	称为正整数 `n` 的 <b>`a` 进位 (base-`a` 或 radix-`a`) 表示</b>.
</p>

<p class="proof">
	由最大自然数原理, 对正整数 `n` 存在唯一的 `m ge 0`, 使
	`a^m le n lt a^(m+1)`.
	由带余除法, 存在唯一的 `q_0, r_0` 满足
	<span class="formula">
		`n = a q_0 + r_0`, `0 le r_0 lt a`.
	</span>
	对 `m` 使用数学归纳法.
	若 `m = 0`, 则必有 `q_0 = 0`, `1 le r_0 lt a`, 所以结论成立.
	设结论对整数 `m ge 0` 成立, 考虑 `m+1` 的情形.
	因为 `a^(m+1) le n lt a^(m+2)`,
	所以上式中的 `q_0` 满足 `a^m le q_0 lt a^(m+1)`.
	由归纳假设, 存在唯一的 `0 le s_i lt a`, `0 le i le m`, 使
	<span class="formula">
		`q_0 = sum_(i=0)^m s_i a^i`.
	</span>
	所以
	<span class="formula">
		`n = a sum_(i=0)^m s_i a^i + r_0
		= r_0 + sum_(i=1)^(m+1) s_(i-1) a^i`,
	</span>
	即结论对 `m+1` 成立.
</p>

<ol class="example">
	设 `n gt 2` 是奇数. 证明
	<li>`n !| 2^i`, `i = 0, 1, cdots, n-1`;</li>
	<li>存在整数 `1 le d lt n`, 使得 `n | 2^d - 1`;</li>
	<li>设 `d in NN`, `d_0` 是满足 2 的最小正整数,
		则 `d | 2^d - 1` 的充要条件是 `d_0 | d`.
	</li>
</ol>

<ol class="proof">
	<li>设 `i` 是使得 `n | 2^i` 成立的最小的非负整数, 显然 `i gt 0`.
		设 `n = 2k+1`, `k in NN`, 则
		<span class="formula">
			`k * 2^i = (n-1)/2 * 2^i = n * 2^(i-1) - 2^(i-1)`.
		</span>
		因为 `n | k * 2^i`, 所以 `n | 2^(i-1)`. 这与 `i` 的最小性矛盾.
	</li>
	<li>考虑以下 `n` 个数:
		<span class="formula">
			`2^0, 2^1, cdots, 2^(n-1)`,
		</span>
		由 1 知 `n` 不能整除它们中的任何一个. 设 `n` 除它们的余数分别为
		<span class="formula">
			`r_0, r_1, cdots, r_(n-1)`.
		</span>
		这 `n` 个数只能取 `1, 2, cdots, n-1` 这 `n-1` 个值, 由鸽巢原理,
		其中必有两个数相等. 设 `r_i = r_j`, `0 le j lt i lt n`, 则
		<span class="formula">
			`n(q_i - q_j) = 2^i - 2^j = 2^j (2^(i-j) - 1)`,
		</span>
		所以 `n | 2^j (2^(i-j) - 1)`.  取 `d = i-j`,
		反复使用 1 中的推理就有 `n | 2^d - 1`.
	</li>
	<li>只证必要性. 由带余除法得
		<span class="formula">
			`d = d_0 q + r`, `0 le r lt d_0`.
		</span>
		所以
		<span class="formula">
			` 2^d - 1
			= 2^(d_0 q + r) - 2^r + 2^r - 1
			= 2^r (2^(d_0 q)-1) + 2^r - 1`.
		</span>
		因为 `n | 2^d - 1`, `n | 2^(d_0) - 1`, 所以 `n | 2^r - 1`.
		但 `r lt d_0`, 所以只能 `r = 0`, 否则与 `d_0` 的最小性矛盾.
		由<a class="ref" href="#the-division-algorithm"></a>,
		这当且仅当 `d_0 | d`.
	</li>
</ol>

<h2>最大公约数与最小公倍数</h2>

<p class="definition">
	设有 `n` 个整数 `a_1, a_2, cdots, a_n`, 若 `d | a_1`, `d | a_2,
	cdots`, `d | a_n`, 则称 `d` 是它们的<b>公约数</b>或<b>公因数</b>.
	当这些整数不全为零时, 它们的公约数个数有限,
	称其中最大的为它们的<b>最大公约数</b>, 记为 `(a_1, a_2, cdots, a_n)`.
	用 `cc D(a_1, a_2, cdots, a_n)` 表示它们的全体公约数, 则
	<span class="formula">
		`(a_1, a_2, cdots, a_n) = max cc D(a_1, a_2, cdots, a_n)`.
	</span>
	由定义知, 最大公约数是正整数.
</p>

<ol class="theorem" id="the-gcd">
	<li>` (a_(i_1), a_(i_2), cdots, a_(i_n))
		= (|a_1|, |a_2|, cdots, |a_n|)`, `(i_1, i_2, cdots, i_n)` 是
		`1, 2, cdots, n` 的一种排列;
	</li>
	<li>`(a_1, a_2, cdots, a_n) = (a_1, a_2, cdots, a_n, k a_1)`,
		`AA k in ZZ`;
	</li>
	<li>`(a_1, a_2, cdots, a_n) = (a_1, a_2, cdots, a_n + k a_1)`,
		`AA k in ZZ`.
	</li>
	<li>若 `a_1 | a_i`, `i = 2, cdots, n`, 则
		`(a_1, a_2, cdots, a_n) = |a_1|`.
	</li>
</ol>

<p class="proof">
	1, 2, 3 由公约数定义及整除性质直接推出.
	为证 4, 首先由定义知 `a_1 in cc D(a_1, a_2, cdots, a_n)`,
	设 `d in cc D(a_1, a_2, cdots, a_n)`, 则 `d | a_1`
	再由<a class="ref" href="#the-divisor"></a>的 5, `d le |a_1|`.
</p>

<p class="theorem">
	设 `a in ZZ`, `p` 是素数, 则
	<span class="formula">
		`(p, a) = {
			(p, if p | a),
			(1, if p !| a)
		:}`.
	</span>
</p>

</body>

<script src="../js/note.js?type=math"></script>

</html>
